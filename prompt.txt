
okay so here is my current project that named diet helper and helps me to organize my diet:
it consists of index html style css and those js files:
app,ui,data,modal,models,config 

i will give you every files:

first of all just get familiar with my code
index.html:


<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Diet Helper</title>
    <link rel="stylesheet" href="style.css" />
  </head>
  <body>
    <h1>Diet Helper</h1>

    <button id="addCategoryBtn" title="Add Category">Add Category</button>
    <button id="manageTagsBtn" title="Manage Tags (Ctrl+T)">Manage Tags</button>
    <button id="editModeBtn" title="Edit Mode">Edit</button>
    <button id="bulkSelectBtn" style="display: none">Select</button>

    <div style="position: fixed; bottom: 10px; right: 10px; font-size: 12px; color: #666">
      Press <kbd>?</kbd> for keyboard shortcuts
    </div>

    <!-- Filter Panel -->
    <div id="filterPanel" class="filter-panel">
      <div class="filter-header" id="filterHeader">
        <span>üè∑Ô∏è Filter by Tags</span>
        <span id="filterCount" class="filter-count"></span>
        <span class="filter-toggle" id="filterToggle">‚ñº</span>
      </div>
      <div id="filterContent" class="filter-content">
        <div class="filter-content-inner">
          <div id="filterTags" class="filter-tags"></div>
          <div class="filter-actions">
            <label style="float: left; font-size: 14px">
              <input type="checkbox" id="filterModeToggle" style="margin-right: 5px" />
              Match ANY tag (instead of ALL)
            </label>
            <button id="clearFiltersBtn" class="btn-secondary">Clear All</button>
          </div>
        </div>
      </div>
    </div>

    <div id="categoriesContainer"></div>

    <!-- Food Details Dropdown -->
    <div id="foodDetailsDropdown" class="dropdown">
      <div id="foodDetailsContent">
        <h2 id="detailsName" style="margin: 0 0 15px 0; font-size: 24px"></h2>

        <div style="display: flex; gap: 15px; margin-bottom: 20px">
          <!-- Image section - 60% -->
          <div style="flex: 0 0 60%">
            <img
              id="detailsImage"
              style="width: 100%; height: auto; object-fit: cover; border-radius: 8px"
              src=""
              alt=""
            />
          </div>

          <!-- Nutrition section - 40% -->
          <div style="flex: 0 0 40%">
            <h4 style="margin: 0 0 10px 0; font-size: 16px">Nutrition Facts</h4>
            <div class="nutrition-display compact">
              <div class="nutrition-row">
                <span>Protein:</span>
                <span id="detailsProtein">-</span>
              </div>
              <div class="nutrition-row">
                <span>Fat:</span>
                <span id="detailsFat">-</span>
              </div>
              <div class="nutrition-row">
                <span>Carbs:</span>
                <span id="detailsCarbs">-</span>
              </div>
              <div class="nutrition-row">
                <span>Fiber:</span>
                <span id="detailsFiber">-</span>
              </div>
              <div class="nutrition-row">
                <span>Sugar:</span>
                <span id="detailsSugar">-</span>
              </div>
              <div class="nutrition-row">
                <span>Sodium:</span>
                <span id="detailsSodium">-</span>
              </div>
            </div>
          </div>
        </div>

        <!-- Tags section -->
        <div class="details-section" style="margin-bottom: 15px">
          <h4 style="margin: 0 0 8px 0">Tags</h4>
          <div id="detailsTags"></div>
        </div>

        <!-- Notes Section -->
        <div id="detailsNotesSection" class="details-section">
          <h4>Notes</h4>
          <p id="detailsNotes"></p>
        </div>

        <!-- Specific Data Section -->
        <div id="detailsSpecificSection" class="details-section">
          <h4>Specific Information</h4>
          <p id="detailsSpecificData"></p>
        </div>
      </div>

      <div class="modal-buttons">
        <button id="editFoodBtn" class="btn-primary">Edit</button>
        <button id="deleteFoodBtn" class="btn-danger">Delete</button>
        <button id="closeFoodDetailsBtn" class="btn-secondary">Close</button>
      </div>
    </div>

    <!-- Add Food Dropdown -->
    <div id="addFoodDropdown" class="dropdown">
      <h3>Add New Food</h3>

      <!-- Basic Info Section -->
      <div class="form-section">
        <h4>Basic Information</h4>
        <div class="form-group">
          <input type="text" id="foodName" placeholder="Enter food name" />
          <div id="foodNameError" class="error-message hidden">Please enter food name</div>
        </div>
        <div class="form-group">
          <label>Food Image:</label>
          <input type="file" id="foodImage" accept="image/*" />
        </div>
        <div class="form-group">
          <label>Notes:</label>
          <textarea
            id="foodNotes"
            placeholder="Cooking tips, where to buy, etc."
            rows="2"
          ></textarea>
        </div>
      </div>

      <!-- Nutrition Section -->
      <div class="form-section">
        <h4>Nutrition Facts (per serving)</h4>
        <div class="nutrition-grid">
          <div class="nutrition-input">
            <label>Protein (g)</label>
            <input type="number" id="nutritionProtein" min="0" step="0.1" />
          </div>
          <div class="nutrition-input">
            <label>Fat (g)</label>
            <input type="number" id="nutritionFat" min="0" step="0.1" />
          </div>
          <div class="nutrition-input">
            <label>Carbs (g)</label>
            <input type="number" id="nutritionCarbs" min="0" step="0.1" />
          </div>
          <div class="nutrition-input">
            <label>Fiber (g)</label>
            <input type="number" id="nutritionFiber" min="0" step="0.1" />
          </div>
          <div class="nutrition-input">
            <label>Sugar (g)</label>
            <input type="number" id="nutritionSugar" min="0" step="0.1" />
          </div>
          <div class="nutrition-input">
            <label>Sodium (mg)</label>
            <input type="number" id="nutritionSodium" min="0" step="1" />
          </div>
        </div>
      </div>

      <!-- Specific Data Section -->
      <div class="form-section">
        <h4>Specific Information</h4>
        <div class="form-group">
          <textarea
            id="foodSpecificData"
            placeholder="e.g., Rich in B vitamins, High in antioxidants, Good source of omega-3..."
            rows="2"
          ></textarea>
        </div>
      </div>

      <!-- Tags Section -->
      <div class="form-section">
        <h4>Tags</h4>
        <div id="tagsList"></div>
      </div>

      <div class="modal-buttons">
        <button id="saveFoodBtn" class="btn-primary">Save Food</button>
        <button id="cancelFoodBtn" class="btn-secondary">Cancel</button>
      </div>
    </div>

    <!-- Edit Food Dropdown -->
    <div id="editFoodDropdown" class="dropdown">
      <div class="form-section">
        <h2 style="margin: 0 0 15px 0; font-size: 20px">Edit Food</h2>
        <div class="form-group">
          <label style="font-weight: bold; margin-bottom: 5px; display: block">Food Name</label>
          <input
            type="text"
            id="editFoodName"
            placeholder="Enter food name"
            style="width: 100%; font-size: 16px"
          />
          <div id="editFoodNameError" class="error-message hidden">Please enter food name</div>
        </div>
      </div>

      <div style="display: flex; gap: 15px; margin-bottom: 20px">
        <!-- Image section - 60% -->
        <div style="flex: 0 0 60%">
          <label style="font-weight: bold; margin-bottom: 5px; display: block">Food Image</label>
          <input type="file" id="editFoodImage" accept="image/*" style="width: 100%" />
          <div id="currentImagePreview" style="margin-top: 10px"></div>
        </div>

        <!-- Nutrition section - 40% -->
        <div style="flex: 0 0 40%">
          <h4 style="margin: 0 0 10px 0; font-size: 16px">Nutrition Facts</h4>
          <div class="nutrition-edit-compact">
            <div class="nutrition-input-row">
              <label>Protein (g)</label>
              <input type="number" id="editNutritionProtein" min="0" step="0.1" />
            </div>
            <div class="nutrition-input-row">
              <label>Fat (g)</label>
              <input type="number" id="editNutritionFat" min="0" step="0.1" />
            </div>
            <div class="nutrition-input-row">
              <label>Carbs (g)</label>
              <input type="number" id="editNutritionCarbs" min="0" step="0.1" />
            </div>
            <div class="nutrition-input-row">
              <label>Fiber (g)</label>
              <input type="number" id="editNutritionFiber" min="0" step="0.1" />
            </div>
            <div class="nutrition-input-row">
              <label>Sugar (g)</label>
              <input type="number" id="editNutritionSugar" min="0" step="0.1" />
            </div>
            <div class="nutrition-input-row">
              <label>Sodium (mg)</label>
              <input type="number" id="editNutritionSodium" min="0" step="1" />
            </div>
          </div>
        </div>
      </div>

      <!-- Tags Section -->
      <div class="form-section">
        <h4>Tags</h4>
        <div id="editTagsList"></div>
      </div>

      <!-- Notes Section -->
      <div class="form-section">
        <h4>Notes</h4>
        <textarea
          id="editFoodNotes"
          placeholder="Cooking tips, where to buy, etc."
          rows="3"
          style="width: 100%"
        ></textarea>
      </div>

      <!-- Specific Data Section -->
      <div class="form-section">
        <h4>Specific Information</h4>
        <textarea
          id="editFoodSpecificData"
          placeholder="e.g., Rich in B vitamins, High in antioxidants..."
          rows="3"
          style="width: 100%"
        ></textarea>
      </div>

      <div class="modal-buttons">
        <button id="updateFoodBtn" class="btn-primary">Update Food</button>
        <button id="cancelEditBtn" class="btn-secondary">Cancel</button>
      </div>
    </div>

    <!-- Manage Tags Dropdown -->
    <div id="manageTagsDropdown" class="dropdown">
      <h3>Manage Tags</h3>
      <div class="form-group">
        <input type="text" id="newTagName" placeholder="Enter tag name" />
        <div id="tagNameError" class="error-message hidden">Please enter tag name</div>
        <button id="addTagBtn" class="btn-primary">Add Tag</button>
      </div>
      <div id="existingTags"></div>
      <div class="modal-buttons">
        <button id="closeTagsBtn" class="btn-secondary">Close</button>
      </div>
    </div>

    <!-- Add Category Modal -->
    <div id="addCategoryDropdown" class="dropdown">
      <h3>Add New Category</h3>
      <div class="form-group">
        <input type="text" id="categoryNameInput" placeholder="Enter category name" />
        <div id="categoryNameError" class="error-message hidden">Please enter category name</div>
      </div>
      <div class="modal-buttons">
        <button id="saveCategoryBtn" class="btn-primary">Save Category</button>
        <button id="cancelCategoryBtn" class="btn-secondary">Cancel</button>
      </div>
    </div>

    <!-- Confirmation Modal -->
    <div id="confirmationDropdown" class="dropdown">
      <h3 id="confirmTitle">Confirm Delete</h3>
      <p id="confirmMessage" style="margin: 20px 0; color: #333"></p>
      <div class="modal-buttons">
        <button id="confirmYesBtn" class="btn-danger">Delete</button>
        <button id="confirmNoBtn" class="btn-secondary">Cancel</button>
      </div>
    </div>

    <!-- Add Subgroup Modal -->
    <div id="addSubgroupDropdown" class="dropdown">
      <h3>Add New Subgroup</h3>
      <div class="form-group">
        <input type="text" id="subgroupNameInput" placeholder="Enter subgroup name" />
        <div id="subgroupNameError" class="error-message hidden">Please enter subgroup name</div>
      </div>
      <div class="modal-buttons">
        <button id="saveSubgroupBtn" class="btn-primary">Save Subgroup</button>
        <button id="cancelSubgroupBtn" class="btn-secondary">Cancel</button>
      </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
    <script type="module" src="app.js"></script>
  </body>
</html>

style.css:
body {
  font-family: Arial, sans-serif;
  margin: 20px;
  min-height: 100vh;
  overflow-y: auto;
}

button {
  padding: 10px 15px;
  margin: 5px;
  cursor: pointer;
}

.dropdown {
  display: none;
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: white;
  border: 2px solid #ccc;
  padding: 20px;
  padding-bottom: 0;
  z-index: 1000;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
  border-radius: 8px;
  min-width: 300px;
  max-height: 80vh;
  overflow-y: auto;
}

.dropdown.active {
  display: block;
}

.modal-overlay {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.5);
  z-index: 999;
}

.modal-overlay.active {
  display: block;
}

.form-group {
  margin: 10px 0;
}

.form-group label {
  display: block;
  margin-bottom: 5px;
}

.form-group input,
.form-group select {
  width: 200px;
  padding: 5px;
}

.tag-item {
  margin: 5px 0;
  padding: 5px;
  border: 1px solid #ddd;
}

.tag-checkbox {
  margin-right: 10px;
}

/* Food item styles */
.food-item {
  border: 1px solid #ccc;
  margin: 5px;
  padding: 5px;
  display: inline-block;
  width: 110px;
  text-align: center;
  vertical-align: top;
  position: relative;
  overflow: visible;
  z-index: 1;
  transition: opacity 0.3s ease;
}

.food-item:hover {
  z-index: 100;
}

.food-image {
  width: 100px;
  height: 100px;
  object-fit: cover;
  display: block;
  margin: 0 auto 5px auto;
  cursor: pointer;
  box-sizing: border-box;
  transition: all 0.3s ease;
  position: relative;
}

.food-image.no-image {
  background: #f0f0f0;
  line-height: 100px;
  text-align: center;
  font-size: 11px;
  color: #999;
}

.food-item:hover .food-image {
  transform: scale(1.8);
  box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
  border: 2px solid #fff;
  z-index: 100;
  position: relative;
}

/* Edit mode styles */
.edit-mode .food-item {
  cursor: move;
  transition: transform 0.2s;
}

.edit-mode .food-item:hover {
  transform: scale(1.05);
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
}

.edit-mode .food-item:hover .food-image {
  transform: scale(1.6);
}
/* Disable image hover in edit mode and bulk select mode */
.edit-mode .food-item:hover .food-image,
.bulk-select-mode .food-item:hover .food-image {
  transform: none !important;
  box-shadow: none !important;
  border: none !important;
  z-index: 1 !important;
}

/* Also disable the background effect in these modes */
.edit-mode .food-item:hover::after,
.bulk-select-mode .food-item:hover::after {
  width: 100% !important;
  height: 100% !important;
  background: none !important;
  box-shadow: none !important;
}
.food-item::after {
  content: '';
  position: absolute;
  top: 50%;
  left: 50%;
  width: 100%;
  height: 100%;
  transform: translate(-50%, -50%);
  border-radius: 4px;
  pointer-events: none;
  transition: all 0.3s ease;
  z-index: -1;
}

.food-item:hover::after {
  width: 180px;
  height: 180px;
  background: rgba(255, 255, 255, 0.9);
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
}

.food-name {
  font-size: 12px;
  font-weight: bold;
  margin: 3px 0;
}

.food-tags {
  font-size: 12px;
  color: #666;
}

.error-message {
  color: red;
  font-size: 12px;
  margin-top: 5px;
}

.hidden {
  display: none;
}

/* Modal buttons */
.modal-buttons {
  display: flex;
  gap: 10px;
  justify-content: flex-end;
  margin-top: 20px;
  padding-top: 15px;
  padding-bottom: 20px;
  border-top: 1px solid #eee;
  position: sticky;
  bottom: 0;
  background: white;
  margin-left: -20px;
  margin-right: -20px;
  padding-left: 20px;
  padding-right: 20px;
}

.btn-primary {
  background-color: #007bff;
  color: white;
  border: none;
  border-radius: 4px;
}

.btn-primary:hover {
  background-color: #0056b3;
}

.btn-danger {
  background-color: #dc3545;
  color: white;
  border: none;
  border-radius: 4px;
}

.btn-danger:hover {
  background-color: #c82333;
}

.btn-secondary {
  background-color: #6c757d;
  color: white;
  border: none;
  border-radius: 4px;
}

.btn-secondary:hover {
  background-color: #545b62;
}

#modalOverlay {
  display: none !important;
  visibility: hidden !important;
}

input[type='text'] {
  border: 1px solid #007bff;
  border-radius: 3px;
  outline: none;
}

/* Category styles */
.category-container {
  border: 1px solid #ccc;
  margin: 10px;
  padding: 8px 10px 10px 10px;
}

.edit-mode .category-container {
  border: 2px solid #007bff !important;
  position: relative;
}

.category-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 0px;
  padding: 2px 0;
  min-height: 28px;
}

.edit-mode .category-header {
  cursor: move;
  background: #f5f5f5;
  margin: -2px -10px 3px -10px;
  padding: 3px 10px;
}

.edit-mode .foods-container {
  min-height: 100px;
  border: 2px dashed transparent;
  transition: all 0.3s ease;
}

/* Sortable styles */
.sortable-ghost {
  opacity: 0.4;
}

.sortable-drag {
  opacity: 0.8;
  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
}

.edit-mode .food-item.sortable-chosen {
  opacity: 0.4;
  transform: scale(1.05);
  box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
}

.edit-mode .sortable-ghost {
  opacity: 0.2;
}

#categoriesContainer {
  padding-bottom: 50px;
}

#confirmationOverlay {
  z-index: 1010;
}

#confirmationDropdown {
  z-index: 1011;
}

/* Filter Panel */
.filter-panel {
  margin: 20px 5px;
  border: 1px solid #ddd;
  border-radius: 8px;
  background: #f8f9fa;
  overflow: hidden;
  transition: all 0.3s ease;
}

.filter-header {
  padding: 12px 15px;
  background: #e9ecef;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: space-between;
  user-select: none;
  font-weight: 500;
}

.filter-header:hover {
  background: #dee2e6;
}

.filter-count {
  background: #007bff;
  color: white;
  padding: 2px 8px;
  border-radius: 12px;
  font-size: 12px;
  margin-left: 10px;
  display: none;
}

.filter-count.active {
  display: inline-block;
}

.filter-toggle {
  transition: transform 0.3s ease;
  font-size: 12px;
  color: #6c757d;
}

.filter-toggle.open {
  transform: rotate(180deg);
}

.filter-content {
  height: 0;
  overflow: hidden;
  transition: height 0.25s ease-out;
}

.filter-content-inner {
  padding: 15px;
}

.filter-tags {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  margin-bottom: 15px;
  max-height: 300px;
  overflow-y: auto;
  padding-top: 2px;
}

.filter-tag-item {
  display: inline-flex;
  align-items: center;
  padding: 8px 16px;
  background: white;
  border: 1px solid #ddd;
  border-radius: 20px;
  cursor: pointer;
  transition: all 0.2s ease;
  user-select: none;
  font-size: 14px;
}

.filter-tag-item:hover {
  background: #f0f0f0;
  border-color: #007bff;
  transform: translateY(-1px);
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.filter-tag-item.selected {
  background: #007bff;
  color: white;
  border-color: #007bff;
}

.filter-tag-item input[type='checkbox'] {
  display: none;
}

.filter-actions {
  border-top: 1px solid #ddd;
  padding-top: 10px;
  text-align: right;
}

#clearFiltersBtn {
  padding: 6px 15px;
  font-size: 14px;
}

.food-item.filtered-out {
  opacity: 0.3;
  pointer-events: none;
}

/* Animations */
@keyframes slideIn {
  from {
    transform: translateX(100%);
    opacity: 0;
  }
  to {
    transform: translateX(0);
    opacity: 1;
  }
}

@keyframes slideOut {
  from {
    transform: translateX(0);
    opacity: 1;
  }
  to {
    transform: translateX(100%);
    opacity: 0;
  }
}

@keyframes slideUp {
  from {
    transform: translateX(-50%) translateY(100%);
    opacity: 0;
  }
  to {
    transform: translateX(-50%) translateY(0);
    opacity: 1;
  }
}

@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(-10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes fadeOut {
  from {
    opacity: 1;
    transform: translateY(0);
  }
  to {
    opacity: 0;
    transform: translateY(-10px);
  }
}

/* Bulk selection */
.bulk-select-mode .food-item {
  position: relative;
  cursor: pointer;
}

.bulk-select-mode .food-item::before {
  content: '';
  position: absolute;
  top: 5px;
  right: 5px;
  width: 20px;
  height: 20px;
  border: 2px solid #007bff;
  border-radius: 3px;
  background: white;
  z-index: 10;
}

.bulk-select-mode .food-item.selected::before {
  background: #007bff;
  content: '‚úì';
  color: white;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: bold;
}

.bulk-select-mode .food-item.selected {
  outline: 2px solid #007bff;
  outline-offset: 2px;
}

.bulk-actions-bar {
  position: fixed;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%);
  background: #333;
  color: white;
  padding: 10px 20px;
  border-radius: 30px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
  display: flex;
  align-items: center;
  gap: 15px;
  z-index: 1000;
  animation: slideUp 0.3s ease-out;
}

.bulk-actions-bar button {
  background: transparent;
  color: white;
  border: 1px solid white;
  padding: 5px 15px;
  border-radius: 20px;
  cursor: pointer;
}

.bulk-actions-bar button:hover {
  background: white;
  color: #333;
}

.bulk-actions-bar .selected-count {
  font-weight: bold;
}

/* Form sections */
.form-section {
  margin-bottom: 20px;
  padding-bottom: 15px;
  border-bottom: 1px solid #eee;
}

.form-section:last-of-type {
  border-bottom: none;
  margin-bottom: 10px;
}

.form-section h4 {
  margin: 0 0 10px 0;
  color: #333;
  font-size: 16px;
}

/* Nutrition grid */
.nutrition-grid {
  display: grid;
  grid-template-columns: 1fr 1fr 1fr;
  gap: 10px;
}

.nutrition-input {
  display: flex;
  flex-direction: column;
}

.nutrition-input label {
  font-size: 12px;
  color: #666;
  margin-bottom: 3px;
}

.nutrition-input input {
  padding: 5px;
  border: 1px solid #ddd;
  border-radius: 3px;
  width: 100%;
}

/* Textarea styling */
textarea {
  width: 100%;
  padding: 5px;
  border: 1px solid #ddd;
  border-radius: 3px;
  resize: vertical;
  font-family: Arial, sans-serif;
  font-size: 14px;
}

/* Modal specific widths */
#addFoodDropdown,
#foodDetailsDropdown,
#editFoodDropdown {
  min-width: 500px;
  max-height: 80vh;
  overflow-y: auto;
}

#foodDetailsDropdown,
#editFoodDropdown {
  max-width: 600px;
}

/* Details sections */
.details-section {
  margin: 15px 0;
  padding: 15px;
  background: #f8f9fa;
  border-radius: 5px;
  text-align: left;
}

.details-section h4 {
  margin: 0 0 10px 0;
  color: #333;
  font-size: 16px;
  font-weight: bold;
}

.details-section p {
  margin: 0;
  color: #555;
  line-height: 1.5;
}

/* Nutrition display */
.nutrition-display {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 8px;
}

.nutrition-display.compact {
  display: flex;
  flex-direction: column;
  gap: 3px;
}

.nutrition-display.compact .nutrition-row {
  padding: 3px 8px;
  font-size: 12px;
  display: flex;
  justify-content: space-between;
}

.nutrition-display.compact .nutrition-row span:first-child {
  font-weight: normal;
  color: #666;
}

.nutrition-display.compact .nutrition-row span:last-child {
  font-weight: 600;
  color: #333;
}

.nutrition-row {
  display: flex;
  justify-content: space-between;
  padding: 5px 10px;
  background: white;
  border-radius: 3px;
}

.nutrition-row span:first-child {
  color: #666;
  font-weight: 500;
}

.nutrition-row span:last-child {
  color: #333;
  font-weight: bold;
}

/* Compact nutrition edit */
.nutrition-edit-compact {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.nutrition-input-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 10px;
}

.nutrition-input-row label {
  font-size: 12px;
  color: #666;
  flex: 1;
}

.nutrition-input-row input {
  width: 70px;
  padding: 4px 6px;
  border: 1px solid #ddd;
  border-radius: 3px;
  font-size: 12px;
}

/* Edit modal sections */
#editFoodDropdown .form-section {
  margin-bottom: 15px;
  padding-bottom: 15px;
}

#editFoodDropdown .form-section:last-of-type {
  margin-bottom: 0;
}

#editFoodDropdown h4 {
  margin: 0 0 8px 0;
  font-size: 16px;
  font-weight: bold;
  color: #333;
}

/* Modal z-index stacking */
#foodDetailsOverlay {
  z-index: 999;
}

#foodDetailsDropdown {
  z-index: 1000;
}

#editFoodOverlay {
  z-index: 1001;
}

#editFoodDropdown {
  z-index: 1002;
}

/* Selectable tags */
.selectable-tag {
  display: inline-flex;
  align-items: center;
  padding: 6px 14px;
  background: #f0f0f0;
  border: 1px solid #ddd;
  border-radius: 20px;
  cursor: pointer;
  user-select: none;
  transition: all 0.2s ease;
  font-size: 14px;
  white-space: nowrap;
}

.selectable-tag:hover {
  background: #e0e0e0;
  border-color: #007bff;
  transform: translateY(-1px);
}

.selectable-tag.selected {
  background: #007bff;
  color: white;
  border-color: #007bff;
}

.selectable-tag.selected:hover {
  background: #0056b3;
  border-color: #0056b3;
}

/* Tag display */
#detailsTags .tag-badge {
  background: #e9ecef;
  padding: 4px 12px;
  border-radius: 15px;
  font-size: 13px;
  color: #495057;
  border: 1px solid #dee2e6;
}
.subgroup-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 8px;
  padding: 3px 5px;
  background: #e9ecef;
  border-radius: 4px;
}

.edit-mode .subgroup-header {
  cursor: move;
}

.subgroup-container {
  background: #f8f9fa;
  border: 1px solid #e9ecef;
  border-radius: 6px;
  margin: 8px;
  padding: 6px;
  transform: scale(0.95);
  transform-origin: top left;
  overflow: hidden;
}

.subgroup-foods {
  display: grid;
  grid-template-columns: repeat(4, 100px);
  min-height: 60px;
  gap: 2px;
  justify-content: start; /* Changed from center to start */
  padding: 0;
}

.subgroup-container .food-item {
  transform: scale(0.88);
  margin: 2px;
  width: 100px;
  justify-self: start; /* Changed from center to start */
}
.edit-mode .subgroups-drop-zone:empty {
  border: 2px dashed #dee2e6 !important;
  background: rgba(0, 0, 0, 0.02);
}

.edit-mode .subgroups-drop-zone:empty::after {
  content: 'Drop subgroups here';
  display: block;
  text-align: center;
  width: 100%;
  color: #999;
  font-size: 12px;
  padding: 40px 0;
  grid-column: 1 / -1; /* Span across all columns */
}

app.js:
import { CONFIG } from './config.js'
import { Food, Category } from './models.js'
import { DataManager } from './data.js'
import { UIManager } from './ui.js'
import { ModalManager } from './modal.js'

class DietHelper {
  constructor() {
    this.foods = []
    this.tags = []
    this.categories = []
    this.currentCategoryId = null
    this.isEditMode = false
    this.categorySortable = null
    this.foodSortables = {}
    this.subgroupSortables = {}
    this.currentFoodId = null
    this.editingSubgroupId = null
    this.dataManager = new DataManager()
    this.uiManager = new UIManager()
    this.modalManager = new ModalManager()
    this.selectedFilterTags = new Set()
    this.isFilterPanelOpen = false
    this.selectedFoods = new Set()
    this.isBulkSelectMode = false
    this.init()
  }

  async init() {
    const result = await this.dataManager.loadData()
    if (result.success) {
      this.foods = result.data.foods
      this.tags = result.data.tags
      this.categories = result.data.categories || []
      this.uiManager.renderCategories(this.categories, this.isEditMode)
    }
    this.initializeEventListeners()
    this.initializeFilterPanel()
    this.initializeKeyboardShortcuts()
  }

  initializeEventListeners() {
    document.getElementById('manageTagsBtn').addEventListener('click', () => {
      this.showManageTagsForm()
    })

    document.getElementById('editModeBtn').addEventListener('click', () => {
      this.toggleEditMode()
    })

    document.getElementById('addCategoryBtn').addEventListener('click', () => {
      this.showAddCategoryForm()
    })

    document.getElementById('saveCategoryBtn').addEventListener('click', () => {
      this.saveCategory()
    })

    document.getElementById('cancelCategoryBtn').addEventListener('click', () => {
      this.hideAddCategoryForm()
    })

    document.getElementById('saveFoodBtn').addEventListener('click', () => {
      this.saveFood()
    })

    document.getElementById('cancelFoodBtn').addEventListener('click', () => {
      this.hideAddFoodForm()
    })

    document.getElementById('addTagBtn').addEventListener('click', () => {
      this.addTag()
    })

    document.getElementById('closeFoodDetailsBtn').addEventListener('click', () => {
      this.hideFoodDetails()
    })

    document.getElementById('deleteFoodBtn').addEventListener('click', () => {
      this.deleteFood()
    })

    document.getElementById('closeTagsBtn').addEventListener('click', () => {
      this.hideManageTagsForm()
    })

    document.getElementById('bulkSelectBtn').addEventListener('click', () => {
      this.toggleBulkSelectMode()
    })

    document.getElementById('editFoodBtn').addEventListener('click', () => {
      this.editFood()
    })

    document.getElementById('updateFoodBtn').addEventListener('click', () => {
      this.updateFood()
    })

    document.getElementById('cancelEditBtn').addEventListener('click', () => {
      this.hideEditFoodForm()
    })

    document.getElementById('saveSubgroupBtn').addEventListener('click', () => {
      this.saveSubgroup()
    })

    document.getElementById('cancelSubgroupBtn').addEventListener('click', () => {
      this.hideAddSubgroupForm()
    })
  }

  initializeKeyboardShortcuts() {
    document.addEventListener('keydown', (e) => {
      const isInputActive = ['INPUT', 'TEXTAREA'].includes(document.activeElement.tagName)

      if (e.key === 'Escape') {
        e.preventDefault()
        this.modalManager.closeActiveModal()
        return
      }

      if (isInputActive && e.key !== 'Escape') return

      if (e.ctrlKey && e.key === 'n') {
        e.preventDefault()
        if (this.categories.length === 0) {
          this.showAddCategoryForm()
        } else if (this.categories.length === 1) {
          this.showAddFoodForm(this.categories[0].id)
        } else {
          this.showCategorySelector()
        }
      }

      if (e.ctrlKey && e.key === 't') {
        e.preventDefault()
        this.showManageTagsForm()
      }

      if (e.ctrlKey && e.key === 's') {
        e.preventDefault()
        this.handleSaveShortcut()
      }

      if (e.ctrlKey && e.key === 'f') {
        e.preventDefault()
        if (!this.isFilterPanelOpen) {
          this.toggleFilterPanel()
        }
        setTimeout(() => {
          const firstTag = document.querySelector('.filter-tag-item input')
          if (firstTag) firstTag.focus()
        }, 100)
      }

      if (e.key === 'Delete' && this.isBulkSelectMode && this.selectedFoods.size > 0) {
        e.preventDefault()
        this.bulkDelete()
      }

      if (e.key === '/' && !isInputActive) {
        e.preventDefault()
        this.showKeyboardShortcutsHelp()
      }
    })
  }

  showCategorySelector() {
    const overlay = document.createElement('div')
    overlay.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.5);
    z-index: 1999;
  `

    const selectorModal = document.createElement('div')
    selectorModal.style.cssText = `
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: white;
    padding: 20px;
    border-radius: 8px;
    box-shadow: 0 4px 20px rgba(0,0,0,0.3);
    z-index: 2000;
    max-width: 400px;
    min-width: 300px;
  `

    let categoriesHtml = this.categories
      .map(
        (cat, index) =>
          `<button class="category-select-btn" data-id="${cat.id}" style="
      display: block;
      width: 100%;
      padding: 10px;
      margin: 5px 0;
      text-align: left;
      border: 1px solid #ddd;
      border-radius: 4px;
      cursor: pointer;
      background: white;
    ">
      ${index + 1}. ${cat.name}
    </button>`
      )
      .join('')

    selectorModal.innerHTML = `
    <h3 style="margin-top: 0;">Select Category for New Food</h3>
    <div style="max-height: 300px; overflow-y: auto;">
      ${categoriesHtml}
    </div>
    <button id="cancelCategorySelect" style="margin-top: 15px; padding: 5px 15px;">Cancel</button>
  `

    document.body.appendChild(overlay)
    document.body.appendChild(selectorModal)

    const closeSelector = () => {
      overlay.remove()
      selectorModal.remove()
    }

    selectorModal.querySelectorAll('.category-select-btn').forEach((btn, index) => {
      btn.onclick = () => {
        const categoryId = parseInt(btn.dataset.id)
        closeSelector()
        this.showAddFoodForm(categoryId)
      }

      if (index < 9) {
        const handler = (e) => {
          if (e.key === String(index + 1)) {
            document.removeEventListener('keydown', handler)
            btn.click()
          }
        }
        document.addEventListener('keydown', handler)
      }
    })

    overlay.onclick = closeSelector
    document.getElementById('cancelCategorySelect').onclick = closeSelector
  }

  handleSaveShortcut() {
    const activeModal = this.modalManager.getActiveModal()

    switch (activeModal) {
      case 'addFood':
        this.saveFood()
        break
      case 'editFood':
        this.updateFood()
        break
      case 'addCategory':
        this.saveCategory()
        break
      case 'manageTags':
        const tagInput = document.getElementById('newTagName')
        if (tagInput && tagInput.value.trim()) {
          this.addTag()
        }
        break
    }
  }

  showKeyboardShortcutsHelp() {
    const overlay = document.createElement('div')
    overlay.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.5);
    z-index: 1999;
  `

    const helpModal = document.createElement('div')
    helpModal.style.cssText = `
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: white;
    padding: 20px;
    border-radius: 8px;
    box-shadow: 0 4px 20px rgba(0,0,0,0.3);
    z-index: 2000;
    max-width: 400px;
  `

    helpModal.innerHTML = `
    <h3 style="margin-top: 0;">Keyboard Shortcuts</h3>
    <div style="line-height: 1.8;">
      <div><kbd>Ctrl+N</kbd> - Add new food</div>
      <div><kbd>Ctrl+T</kbd> - Manage tags</div>
      <div><kbd>Ctrl+S</kbd> - Save current form</div>
      <div><kbd>Ctrl+F</kbd> - Filter foods</div>
      <div><kbd>Delete</kbd> - Delete selected (in bulk mode)</div>
      <div><kbd>Escape</kbd> - Close modal</div>
      <div><kbd>?</kbd> - Show this help</div>
    </div>
    <button id="closeHelpBtn" style="margin-top: 15px; padding: 5px 15px;">Close</button>
  `

    document.body.appendChild(overlay)
    document.body.appendChild(helpModal)

    const closeHelp = () => {
      overlay.remove()
      helpModal.remove()
    }

    overlay.onclick = closeHelp
    document.getElementById('closeHelpBtn').onclick = closeHelp

    const escapeHandler = (e) => {
      if (e.key === 'Escape') {
        closeHelp()
        document.removeEventListener('keydown', escapeHandler)
      }
    }
    document.addEventListener('keydown', escapeHandler)
  }

  showAddFoodForm(categoryId = null) {
    this.modalManager.closeActiveModal()
    this.currentCategoryId = categoryId
    this.uiManager.renderTagsForSelection(this.tags)
    this.modalManager.showAddFood()
  }

  hideAddFoodForm() {
    this.modalManager.hideAddFood()
    this.uiManager.clearFoodForm()
  }

  showManageTagsForm() {
    this.uiManager.renderExistingTags(this.tags)
    this.modalManager.showManageTags()
  }

  hideManageTagsForm() {
    this.modalManager.hideManageTags()
  }

  showFoodDetails(foodId) {
    const food = this.foods.find((f) => f.id === foodId)
    if (!food) return

    this.currentFoodId = foodId
    this.uiManager.showFoodDetails(food, this.tags)
    this.modalManager.showFoodDetails()
  }

  hideFoodDetails() {
    this.currentFoodId = null
    this.currentCategoryId = null
    this.currentSubgroupId = null // Add this line
    this.modalManager.hideFoodDetails()

    setTimeout(() => {
      if (document.activeElement === document.body) {
        document.activeElement.blur()
      }
      document.body.removeAttribute('tabIndex')
      document.body.style.overflow = 'auto'
      document.body.offsetHeight
    }, 50)
  }
  async deleteFood() {
    if (!this.currentFoodId) return

    let foodName = 'this food'

    if (this.currentCategoryId) {
      const category = this.categories.find((c) => c.id === this.currentCategoryId)
      const food = category?.foods.find((f) => f.id === this.currentFoodId)
      foodName = food?.name || 'this food'
    } else {
      const food = this.foods.find((f) => f.id === this.currentFoodId)
      foodName = food?.name || 'this food'
    }

    this.modalManager.showConfirmation(`Are you sure you want to delete "${foodName}"?`, () => {
      this.performDeleteFood(this.currentFoodId)
    })
  }

  async performDeleteFood(foodId) {
    try {
      let food = null

      // Check if we're deleting from a subgroup
      if (this.currentSubgroupId) {
        const category = this.categories.find((c) => c.id === this.currentCategoryId)
        if (category && category.subgroups) {
          const subgroup = category.subgroups.find((s) => s.id === this.currentSubgroupId)
          if (subgroup) {
            food = subgroup.foods.find((f) => f.id === foodId)
            subgroup.foods = subgroup.foods.filter((f) => f.id !== foodId)
          }
        }
      } else if (this.currentCategoryId) {
        const category = this.categories.find((c) => c.id === this.currentCategoryId)
        if (category) {
          food = category.foods.find((f) => f.id === foodId)
          category.foods = category.foods.filter((f) => f.id !== foodId)
        }
      } else {
        food = this.foods.find((f) => f.id === foodId)
        this.foods = this.foods.filter((f) => f.id !== foodId)
      }

      if (food && food.imageUrl && !food.imageUrl.startsWith('data:')) {
        await this.dataManager.deleteImage(food.imageUrl)
      }

      // Reset all current IDs
      this.currentFoodId = null
      this.currentCategoryId = null
      this.currentSubgroupId = null

      await this.saveAllData()
      this.uiManager.renderCategories(this.categories, this.isEditMode)
      this.hideFoodDetails()

      if (typeof require !== 'undefined') {
        setTimeout(() => {
          const currentWindow = window
          currentWindow.blur()
          setTimeout(() => {
            currentWindow.focus()
          }, 50)
        }, 100)
      }
    } catch (error) {
      alert('Failed to delete food. Please try again.')
    }
  }

  async saveFood() {
    const formData = this.uiManager.getFoodFormData()

    if (!formData.name) {
      this.uiManager.showError('foodNameError', CONFIG.MESSAGES.ERRORS.FOOD_NAME_REQUIRED)
      this.uiManager.focusElement('foodName')
      return
    }

    this.uiManager.hideError('foodNameError')

    const saveBtn = document.getElementById('saveFoodBtn')
    const originalText = saveBtn.textContent
    saveBtn.disabled = true
    saveBtn.textContent = 'Saving...'

    let imageUrl = ''
    if (formData.image) {
      const imageResult = await this.dataManager.saveImage(formData.image)
      if (imageResult.success) {
        imageUrl = imageResult.path
      }
    }

    saveBtn.disabled = false
    saveBtn.textContent = originalText

    this.createAndSaveFood(
      formData.name,
      imageUrl,
      formData.tags,
      formData.notes,
      formData.nutrition,
      formData.specificData
    )
  }

  async createAndSaveFood(
    name,
    imageUrl,
    selectedTags,
    notes = '',
    nutrition = null,
    specificData = ''
  ) {
    const newFood = new Food(
      Date.now(),
      name,
      imageUrl,
      false,
      selectedTags,
      notes,
      nutrition,
      specificData
    )

    const validation = this.dataManager.validateFood(newFood)
    if (!validation.isValid) {
      alert('Invalid food data: ' + validation.errors.join(', '))
      return
    }

    if (this.currentSubgroupId) {
      const category = this.categories.find((c) => c.id === this.currentCategoryId)
      if (category) {
        const subgroup = category.subgroups.find((s) => s.id === this.currentSubgroupId)
        if (subgroup) {
          subgroup.foods.push(newFood)
        }
      }
    } else if (this.currentCategoryId) {
      const category = this.categories.find((c) => c.id === this.currentCategoryId)
      if (category) {
        category.foods.push(newFood)
      }
    } else {
      this.foods.push(newFood)
    }

    this.currentSubgroupId = null
    await this.saveAllData()
    this.uiManager.renderCategories(this.categories, this.isEditMode)
    this.hideAddFoodForm()

    // Re-enable sorting if in edit mode
    if (this.isEditMode) {
      this.disableFoodSorting()
      setTimeout(() => {
        this.enableCategorySorting()
      }, 150)
    }
  }

  async addTag() {
    const formData = this.uiManager.getTagFormData()

    if (!formData.name) {
      this.uiManager.showError('tagNameError', CONFIG.MESSAGES.ERRORS.TAG_NAME_REQUIRED)
      this.uiManager.focusElement('newTagName')
      return
    }

    this.uiManager.hideError('tagNameError')

    const newTag = {
      id: Date.now(),
      name: formData.name,
    }

    const validation = this.dataManager.validateTag(newTag)
    if (!validation.isValid) {
      alert('Invalid tag data: ' + validation.errors.join(', '))
      return
    }

    this.tags.push(newTag)
    this.uiManager.clearTagForm()
    await this.saveAllData()
    this.uiManager.renderExistingTags(this.tags)
    this.renderFilterTags()
  }

  async deleteTag(tagId) {
    this.modalManager.showConfirmation(CONFIG.MESSAGES.CONFIRMATIONS.DELETE_TAG, () => {
      this.performDeleteTag(tagId)
    })
  }

  async performDeleteTag(tagId) {
    this.tags = this.tags.filter((tag) => tag.id !== tagId)
    this.foods.forEach((food) => {
      food.tags = food.tags.filter((id) => id !== tagId)
    })
    await this.saveAllData()
    this.uiManager.renderExistingTags(this.tags)
    this.selectedFilterTags.delete(tagId)
    this.renderFilterTags()
    this.applyFilters()
    this.uiManager.renderFoods(this.foods, this.tags)
  }

  showAddCategoryForm() {
    document.getElementById('categoryNameInput').value = ''
    this.uiManager.hideError('categoryNameError')
    this.modalManager.showAddCategory()
  }

  hideAddCategoryForm() {
    this.modalManager.hideAddCategory()
  }

  saveCategory() {
    const categoryName = document.getElementById('categoryNameInput').value.trim()

    if (!categoryName) {
      this.uiManager.showError('categoryNameError', 'Please enter category name')
      return
    }

    const newCategory = new Category(Date.now(), categoryName, [])
    this.categories.push(newCategory)
    this.saveAllData()
    this.uiManager.renderCategories(this.categories, this.isEditMode)
    this.hideAddCategoryForm()
  }

  showAddSubgroupForm(categoryId) {
    this.currentCategoryId = categoryId
    document.getElementById('subgroupNameInput').value = ''
    this.uiManager.hideError('subgroupNameError')
    this.modalManager.showAddSubgroup()
  }

  hideAddSubgroupForm() {
    this.modalManager.hideAddSubgroup()
  }

  saveSubgroup() {
    const subgroupName = document.getElementById('subgroupNameInput').value.trim()

    if (!subgroupName) {
      this.uiManager.showError('subgroupNameError', 'Please enter subgroup name')
      return
    }

    this.addSubgroup(this.currentCategoryId, subgroupName)
    this.hideAddSubgroupForm()
  }

  addSubgroup(categoryId, name) {
    const category = this.categories.find((c) => c.id === categoryId)
    if (!category) return

    const newSubgroup = {
      id: Date.now(),
      name: name,
      foods: [],
    }

    if (!category.subgroups) {
      category.subgroups = []
    }

    category.subgroups.push(newSubgroup)
    this.saveAllData()
    this.uiManager.renderCategories(this.categories, this.isEditMode)

    // Re-enable sorting if in edit mode
    if (this.isEditMode) {
      // First disable existing sorting to clean up
      this.disableFoodSorting()
      // Then re-enable after a short delay to ensure DOM is updated
      setTimeout(() => {
        this.enableCategorySorting()
      }, 150)
    }
  }
  deleteSubgroup(categoryId, subgroupId) {
    const category = this.categories.find((c) => c.id === categoryId)
    if (!category) return

    const subgroup = category.subgroups.find((s) => s.id === subgroupId)
    if (!subgroup) return

    const message =
      subgroup.foods.length > 0
        ? `Delete "${subgroup.name}" and move its ${subgroup.foods.length} foods to main category?`
        : `Delete empty subgroup "${subgroup.name}"?`

    this.modalManager.showConfirmation(message, () => {
      if (subgroup.foods.length > 0) {
        category.foods.push(...subgroup.foods)
      }
      category.subgroups = category.subgroups.filter((s) => s.id !== subgroupId)
      this.saveAllData()
      this.uiManager.renderCategories(this.categories, this.isEditMode)

      // Re-enable sorting if in edit mode
      if (this.isEditMode) {
        // First disable existing sorting to clean up
        this.disableFoodSorting()
        // Then re-enable after a short delay to ensure DOM is updated
        setTimeout(() => {
          this.enableCategorySorting()
        }, 150)
      }
    })
  }

  startRenameSubgroup(categoryId, subgroupId) {
    const category = this.categories.find((c) => c.id === categoryId)
    if (!category) return

    const subgroup = category.subgroups.find((s) => s.id === subgroupId)
    if (!subgroup) return

    const nameSpan = document.getElementById(`subgroupName-${subgroupId}`)
    if (!nameSpan) return

    const originalName = subgroup.name

    const input = document.createElement('input')
    input.type = 'text'
    input.value = subgroup.name
    input.style.cssText = 'font-weight: bold; padding: 2px 5px; font-size: 14px;'

    nameSpan.parentNode.replaceChild(input, nameSpan)
    input.focus()
    input.select()

    const saveRename = () => {
      const newName = input.value.trim()
      if (newName && newName !== originalName) {
        subgroup.name = newName
        this.saveAllData()
      }
      this.uiManager.renderCategories(this.categories, this.isEditMode)

      // Re-enable sorting if in edit mode
      if (this.isEditMode) {
        this.disableFoodSorting()
        setTimeout(() => {
          this.enableCategorySorting()
        }, 150)
      }
    }

    input.addEventListener('blur', saveRename)
    input.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault()
        saveRename()
      } else if (e.key === 'Escape') {
        this.uiManager.renderCategories(this.categories, this.isEditMode)
      }
    })
  }

  showSubgroupFoodDetails(categoryId, subgroupId, foodId) {
    const category = this.categories.find((c) => c.id === categoryId)
    if (!category) return

    const subgroup = category.subgroups.find((s) => s.id === subgroupId)
    if (!subgroup) return

    const food = subgroup.foods.find((f) => f.id === foodId)
    if (!food) return

    this.currentFoodId = foodId
    this.currentCategoryId = categoryId
    this.currentSubgroupId = subgroupId

    this.uiManager.showFoodDetails(food, this.tags)
    this.modalManager.showFoodDetails()
  }

  showAddFoodToSubgroup(categoryId, subgroupId) {
    this.modalManager.closeActiveModal()
    this.currentCategoryId = categoryId
    this.currentSubgroupId = subgroupId
    this.uiManager.renderTagsForSelection(this.tags)
    this.modalManager.showAddFood()
  }

  toggleEditMode() {
    this.isEditMode = !this.isEditMode

    const editBtn = document.getElementById('editModeBtn')
    const bulkSelectBtn = document.getElementById('bulkSelectBtn')

    editBtn.textContent = this.isEditMode ? 'Done' : 'Edit'
    editBtn.style.backgroundColor = this.isEditMode ? '#28a745' : ''
    bulkSelectBtn.style.display = this.isEditMode ? 'inline-block' : 'none'

    const container = document.getElementById('categoriesContainer')

    if (this.isEditMode) {
      container.classList.add('edit-mode')
      if (this.isBulkSelectMode) {
        this.toggleBulkSelectMode()
      }
    } else {
      container.classList.remove('edit-mode')
      if (this.isBulkSelectMode) {
        this.toggleBulkSelectMode()
      }
    }

    this.uiManager.renderCategories(this.categories, this.isEditMode)

    if (this.isEditMode) {
      setTimeout(() => {
        this.enableCategorySorting()
      }, 150)
    } else {
      this.disableCategorySorting()
    }
  }

  enableCategorySorting() {
    const container = document.getElementById('categoriesContainer')

    this.categorySortable = Sortable.create(container, {
      animation: 150,
      handle: '.category-header',
      draggable: '.category-container',
      scroll: true,
      forceAutoScrollFallback: true,
      scrollSensitivity: 100,
      scrollSpeed: 20,
      onEnd: (evt) => {
        const movedCategory = this.categories.splice(evt.oldIndex, 1)[0]
        this.categories.splice(evt.newIndex, 0, movedCategory)
        this.saveAllData()
      },
    })

    // Enable subgroup sorting between categories
    const sharedSubgroupGroup = 'shared-subgroups'

    document.querySelectorAll('.category-container').forEach((categoryDiv) => {
      const categoryNameEl = categoryDiv.querySelector('[id^="categoryName-"]')
      if (!categoryNameEl) return

      const categoryId = parseInt(categoryNameEl.id.split('-')[1])
      const category = this.categories.find((c) => c.id === categoryId)
      if (!category) return

      // Find or create subgroups container
      let subgroupsGrid = null

      // Look for existing subgroup containers
      const subgroupContainers = categoryDiv.querySelectorAll('.subgroup-container')
      if (subgroupContainers.length > 0) {
        subgroupsGrid = subgroupContainers[0].parentElement
      }

      // If no subgroups container exists, create one for receiving
      if (!subgroupsGrid) {
        const foodsDiv = document.getElementById(`foods-${categoryId}`)
        if (foodsDiv) {
          subgroupsGrid = document.createElement('div')
          subgroupsGrid.style.cssText =
            'display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin: 10px 0; padding: 0 10px; min-height: 100px; border: 2px dashed transparent;'
          subgroupsGrid.className = 'subgroups-drop-zone'
          categoryDiv.insertBefore(subgroupsGrid, foodsDiv)
        }
      }

      if (subgroupsGrid) {
        this.subgroupSortables = this.subgroupSortables || {}
        this.subgroupSortables[`category-${categoryId}`] = Sortable.create(subgroupsGrid, {
          group: sharedSubgroupGroup,
          animation: 150,
          draggable: '.subgroup-container',
          handle: '.subgroup-header',
          scroll: true,
          ghostClass: 'sortable-ghost',
          chosenClass: 'sortable-chosen',
          onEnd: (evt) => {
            if (evt.from === evt.to && evt.oldIndex === evt.newIndex) return

            const fromCategoryDiv = evt.from.closest('.category-container')
            const toCategoryDiv = evt.to.closest('.category-container')

            const fromCategoryId = parseInt(
              fromCategoryDiv.querySelector('[id^="categoryName-"]').id.split('-')[1]
            )
            const toCategoryId = parseInt(
              toCategoryDiv.querySelector('[id^="categoryName-"]').id.split('-')[1]
            )

            const fromCategory = this.categories.find((c) => c.id === fromCategoryId)
            const toCategory = this.categories.find((c) => c.id === toCategoryId)

            if (fromCategory && toCategory) {
              const movedElement = evt.item
              const subgroupId = parseInt(movedElement.id.split('-')[1])

              // Find the subgroup in source category
              let movedSubgroup = null
              let subgroupIndex = -1

              if (fromCategory.subgroups) {
                subgroupIndex = fromCategory.subgroups.findIndex((s) => s.id === subgroupId)
                if (subgroupIndex !== -1) {
                  movedSubgroup = fromCategory.subgroups.splice(subgroupIndex, 1)[0]
                }
              }

              if (movedSubgroup) {
                // Initialize subgroups array if needed
                if (!toCategory.subgroups) {
                  toCategory.subgroups = []
                }

                // Add to new category
                toCategory.subgroups.splice(evt.newIndex, 0, movedSubgroup)

                this.saveAllData()
                this.uiManager.renderCategories(this.categories, this.isEditMode)

                // Re-enable sorting after render
                setTimeout(() => {
                  this.enableCategorySorting()
                }, 150)
              }
            }
          },
        })
      }
    })

    this.enableFoodSorting()
  }

  disableCategorySorting() {
    if (this.categorySortable) {
      this.categorySortable.destroy()
      this.categorySortable = null
    }
    // Disable subgroup sorting
    if (this.subgroupSortables) {
      Object.values(this.subgroupSortables).forEach((sortable) => {
        if (sortable) {
          sortable.destroy()
        }
      })
      this.subgroupSortables = {}
    }
    this.disableFoodSorting()
  }

  enableFoodSorting() {
    const sharedGroup = 'shared-foods'

    const handleDragStart = (evt) => {
      document.querySelectorAll('.empty-category-message').forEach((msg) => {
        msg.style.display = 'none'
      })
      document.querySelectorAll('.empty-subgroup-message').forEach((msg) => {
        msg.style.display = 'none'
      })
    }

    const handleDragEnd = (evt) => {
      this.categories.forEach((category) => {
        const foodsContainer = document.getElementById(`foods-${category.id}`)
        if (foodsContainer) {
          const foodItems = foodsContainer.querySelectorAll('.food-item')
          const emptyMsg = foodsContainer.querySelector('.empty-category-message')

          if (foodItems.length === 0) {
            if (!emptyMsg) {
              const msg = document.createElement('p')
              msg.className = 'empty-category-message'
              msg.style.cssText =
                'color: #666; margin: 40px 0; position: absolute; width: 100%; text-align: center; pointer-events: none;'
              msg.textContent = 'No foods in this category'
              foodsContainer.appendChild(msg)
            } else {
              emptyMsg.style.display = 'block'
            }
          }
        }

        if (category.subgroups) {
          category.subgroups.forEach((subgroup) => {
            const subgroupContainer = document.getElementById(`subgroup-foods-${subgroup.id}`)
            if (subgroupContainer) {
              const foodItems = subgroupContainer.querySelectorAll('.food-item')
              const emptyMsg = subgroupContainer.querySelector('.empty-subgroup-message')

              if (foodItems.length === 0) {
                if (!emptyMsg) {
                  const msg = document.createElement('p')
                  msg.className = 'empty-subgroup-message'
                  msg.style.cssText =
                    'color: #999; font-size: 12px; margin: 10px; position: absolute; width: 100%; text-align: center; pointer-events: none;'
                  msg.textContent = 'No foods in this subgroup'
                  subgroupContainer.appendChild(msg)
                } else {
                  emptyMsg.style.display = 'block'
                }
              }
            }
          })
        }
      })
    }

    const handleFoodMove = (evt) => {
      if (evt.from === evt.to && evt.oldIndex === evt.newIndex) return

      const fromId = evt.from.id
      const toId = evt.to.id

      const movedElement = evt.item
      const foodImage = movedElement.querySelector('.food-image')
      if (!foodImage) return

      const foodId = parseInt(foodImage.dataset.foodId)

      let movedFood = null
      const fromParts = fromId.split('-')

      if (fromParts[0] === 'foods') {
        const fromCategoryId = parseInt(fromParts[1])
        const sourceCategory = this.categories.find((c) => c.id === fromCategoryId)
        if (sourceCategory) {
          const foodIndex = sourceCategory.foods.findIndex((f) => f.id === foodId)
          if (foodIndex !== -1) {
            movedFood = sourceCategory.foods.splice(foodIndex, 1)[0]
          }
        }
      } else if (fromParts[0] === 'subgroup' && fromParts[1] === 'foods') {
        const subgroupId = parseInt(fromParts[2])
        this.categories.forEach((category) => {
          if (category.subgroups) {
            const subgroup = category.subgroups.find((s) => s.id === subgroupId)
            if (subgroup) {
              const foodIndex = subgroup.foods.findIndex((f) => f.id === foodId)
              if (foodIndex !== -1) {
                movedFood = subgroup.foods.splice(foodIndex, 1)[0]
              }
            }
          }
        })
      }

      if (movedFood) {
        const toParts = toId.split('-')

        if (toParts[0] === 'foods') {
          const toCategoryId = parseInt(toParts[1])
          const destCategory = this.categories.find((c) => c.id === toCategoryId)
          if (destCategory) {
            destCategory.foods.splice(evt.newIndex, 0, movedFood)
          }
        } else if (toParts[0] === 'subgroup' && toParts[1] === 'foods') {
          const subgroupId = parseInt(toParts[2])
          this.categories.forEach((category) => {
            if (category.subgroups) {
              const subgroup = category.subgroups.find((s) => s.id === subgroupId)
              if (subgroup) {
                subgroup.foods.splice(evt.newIndex, 0, movedFood)
              }
            }
          })
        }

        this.saveAllData()
      }
    }

    this.categories.forEach((category) => {
      const foodsContainer = document.getElementById(`foods-${category.id}`)
      if (foodsContainer) {
        this.foodSortables[`category-${category.id}`] = Sortable.create(foodsContainer, {
          group: sharedGroup,
          animation: 150,
          draggable: '.food-item',
          scroll: true,
          scrollSensitivity: 30,
          scrollSpeed: 10,
          ghostClass: 'sortable-ghost',
          chosenClass: 'sortable-chosen',
          onStart: handleDragStart,
          onEnd: (evt) => {
            handleFoodMove(evt)
            handleDragEnd(evt)
          },
        })
      }

      if (category.subgroups) {
        category.subgroups.forEach((subgroup) => {
          const subgroupFoodsContainer = document.getElementById(`subgroup-foods-${subgroup.id}`)
          if (subgroupFoodsContainer) {
            this.foodSortables[`subgroup-${subgroup.id}`] = Sortable.create(
              subgroupFoodsContainer,
              {
                group: sharedGroup,
                animation: 150,
                draggable: '.food-item',
                scroll: true,
                scrollSensitivity: 30,
                scrollSpeed: 10,
                ghostClass: 'sortable-ghost',
                chosenClass: 'sortable-chosen',
                onStart: handleDragStart,
                onEnd: (evt) => {
                  handleFoodMove(evt)
                  handleDragEnd(evt)
                },
              }
            )
          }
        })
      }
    })
  }

  disableFoodSorting() {
    Object.values(this.foodSortables).forEach((sortable) => {
      if (sortable) {
        sortable.destroy()
      }
    })
    this.foodSortables = {}
  }

  startRenameCategory(categoryId) {
    const category = this.categories.find((c) => c.id === categoryId)
    if (!category) return

    const nameSpan = document.getElementById(`categoryName-${categoryId}`)
    if (!nameSpan) return

    const originalName = category.name

    const input = document.createElement('input')
    input.type = 'text'
    input.value = category.name
    input.style.cssText = 'font-weight: bold; padding: 2px 5px; margin-right: 10px;'

    nameSpan.parentNode.replaceChild(input, nameSpan)
    input.focus()
    input.select()

    const saveRename = () => {
      const newName = input.value.trim()
      if (newName && newName !== originalName) {
        subgroup.name = newName
        this.saveAllData()
      }
      this.uiManager.renderCategories(this.categories, this.isEditMode)

      // Re-enable sorting if in edit mode
      if (this.isEditMode) {
        this.disableFoodSorting()
        setTimeout(() => {
          this.enableCategorySorting()
        }, 150)
      }
    }

    const cancelRename = (e) => {
      if (e.key === 'Escape') {
        this.uiManager.renderCategories(this.categories, this.isEditMode)
      }
    }

    input.addEventListener('blur', saveRename)
    input.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault()
        saveRename()
      } else if (e.key === 'Escape') {
        cancelRename(e)
      }
    })
  }

  deleteCategory(categoryId) {
    const category = this.categories.find((c) => c.id === categoryId)
    if (!category) return

    const foodCount = category.foods.length
    const message =
      foodCount > 0
        ? `Delete "${category.name}" and its ${foodCount} food${foodCount > 1 ? 's' : ''}?`
        : `Delete empty category "${category.name}"?`

    this.modalManager.showConfirmation(message, () => {
      this.categories = this.categories.filter((c) => c.id !== categoryId)
      this.saveAllData()
      this.uiManager.renderCategories(this.categories, this.isEditMode)

      // Re-enable sorting if in edit mode
      if (this.isEditMode) {
        this.disableFoodSorting()
        setTimeout(() => {
          this.enableCategorySorting()
        }, 150)
      }
    })
  }

  showCategoryFoodDetails(categoryId, foodId) {
    const category = this.categories.find((c) => c.id === categoryId)
    if (!category) return

    const food = category.foods.find((f) => f.id === foodId)
    if (!food) return

    this.currentFoodId = foodId
    this.currentCategoryId = categoryId
    this.currentSubgroupId = null // Make sure this is null for direct foods

    this.uiManager.showFoodDetails(food, this.tags)
    this.modalManager.showFoodDetails()
  }

  async saveAllData() {
    const data = {
      foods: this.foods,
      tags: this.tags,
      categories: this.categories,
    }

    const result = await this.dataManager.saveData(data)
    if (!result.success) {
      console.error('Failed to save data:', result.error)
      alert(CONFIG.MESSAGES.ERRORS.SAVE_FAILED)
    }
  }

  initializeFilterPanel() {
    const filterHeader = document.getElementById('filterHeader')
    filterHeader.addEventListener('click', () => this.toggleFilterPanel())

    const clearBtn = document.getElementById('clearFiltersBtn')
    clearBtn.addEventListener('click', () => this.clearAllFilters())

    this.renderFilterTags()

    const filterModeToggle = document.getElementById('filterModeToggle')
    filterModeToggle.addEventListener('change', () => {
      this.applyFilters()
    })
  }

  toggleFilterPanel() {
    this.isFilterPanelOpen = !this.isFilterPanelOpen

    const filterContent = document.getElementById('filterContent')
    const filterToggle = document.getElementById('filterToggle')

    if (this.isFilterPanelOpen) {
      filterContent.style.height = 'auto'
      const height = filterContent.scrollHeight
      filterContent.style.height = '0'
      filterContent.offsetHeight
      filterContent.style.height = height + 'px'
      filterContent.classList.add('open')
      filterToggle.classList.add('open')
    } else {
      filterContent.style.height = filterContent.scrollHeight + 'px'
      filterContent.offsetHeight
      filterContent.style.height = '0'
      filterContent.classList.remove('open')
      filterToggle.classList.remove('open')
    }
  }

  renderFilterTags() {
    const filterTagsContainer = document.getElementById('filterTags')
    filterTagsContainer.innerHTML = ''

    this.tags.forEach((tag) => {
      const tagDiv = document.createElement('div')
      tagDiv.className = 'filter-tag-item'
      if (this.selectedFilterTags.has(tag.id)) {
        tagDiv.classList.add('selected')
      }

      tagDiv.textContent = tag.name
      tagDiv.dataset.tagId = tag.id

      tagDiv.addEventListener('click', () => {
        this.toggleFilterTag(tag.id)
      })

      filterTagsContainer.appendChild(tagDiv)
    })

    this.updateFilterCount()
  }

  toggleFilterTag(tagId) {
    if (this.selectedFilterTags.has(tagId)) {
      this.selectedFilterTags.delete(tagId)
    } else {
      this.selectedFilterTags.add(tagId)
    }

    this.renderFilterTags()
    this.applyFilters()
  }

  clearAllFilters() {
    this.selectedFilterTags.clear()
    this.renderFilterTags()
    this.applyFilters()
  }

  updateFilterCount() {
    const filterCount = document.getElementById('filterCount')
    const count = this.selectedFilterTags.size

    if (count > 0) {
      filterCount.textContent = `(${count})`
      filterCount.classList.add('active')
    } else {
      filterCount.classList.remove('active')
    }
  }

  applyFilters() {
    const allFoodItems = document.querySelectorAll('.food-item')
    const useOrLogic = document.getElementById('filterModeToggle').checked

    if (this.selectedFilterTags.size === 0) {
      allFoodItems.forEach((item) => {
        item.classList.remove('filtered-out')
      })
      return
    }

    allFoodItems.forEach((foodItem) => {
      const foodImage = foodItem.querySelector('.food-image')
      if (!foodImage) return

      const foodId = parseInt(foodImage.dataset.foodId)
      const categoryId = foodImage.dataset.categoryId
        ? parseInt(foodImage.dataset.categoryId)
        : null
      const subgroupId = foodImage.dataset.subgroupId
        ? parseInt(foodImage.dataset.subgroupId)
        : null

      let food = null

      if (subgroupId && categoryId) {
        // Food is in a subgroup
        const category = this.categories.find((c) => c.id === categoryId)
        if (category && category.subgroups) {
          const subgroup = category.subgroups.find((s) => s.id === subgroupId)
          food = subgroup?.foods.find((f) => f.id === foodId)
        }
      } else if (categoryId) {
        // Food is in direct category
        const category = this.categories.find((c) => c.id === categoryId)
        food = category?.foods.find((f) => f.id === foodId)
      } else {
        // Food is at root level
        food = this.foods.find((f) => f.id === foodId)
      }

      if (food) {
        let shouldShow = false

        if (useOrLogic) {
          shouldShow = food.tags.some((tagId) => this.selectedFilterTags.has(tagId))
        } else {
          shouldShow = Array.from(this.selectedFilterTags).every((tagId) =>
            food.tags.includes(tagId)
          )
        }

        if (shouldShow) {
          foodItem.classList.remove('filtered-out')
        } else {
          foodItem.classList.add('filtered-out')
        }
      }
    })
  }
  toggleBulkSelectMode() {
    this.isBulkSelectMode = !this.isBulkSelectMode
    const bulkSelectBtn = document.getElementById('bulkSelectBtn')
    const container = document.getElementById('categoriesContainer')

    if (this.isBulkSelectMode) {
      bulkSelectBtn.textContent = 'Cancel Select'
      bulkSelectBtn.style.backgroundColor = '#dc3545'
      container.classList.add('bulk-select-mode')
      this.selectedFoods.clear()
      this.showBulkActionsBar()
      this.disableFoodSorting()
    } else {
      bulkSelectBtn.textContent = 'Select'
      bulkSelectBtn.style.backgroundColor = ''
      container.classList.remove('bulk-select-mode')
      this.selectedFoods.clear()
      this.hideBulkActionsBar()
      if (this.isEditMode) {
        this.enableFoodSorting()
      }
      document.querySelectorAll('.food-item.selected').forEach((item) => {
        item.classList.remove('selected')
      })
    }
  }

  showBulkActionsBar() {
    this.hideBulkActionsBar()

    const bar = document.createElement('div')
    bar.className = 'bulk-actions-bar'
    bar.innerHTML = `
    <span class="selected-count">0 selected</span>
    <button onclick="dietHelper.selectAllVisible()">Select All</button>
    <button onclick="dietHelper.unselectAll()">Unselect All</button>
    <button onclick="dietHelper.bulkDelete()" style="background: #dc3545; border-color: #dc3545;">Delete Selected</button>
  `
    document.body.appendChild(bar)

    this.updateBulkActionsBar()
  }

  hideBulkActionsBar() {
    const bar = document.querySelector('.bulk-actions-bar')
    if (bar) bar.remove()
  }

  updateBulkActionsBar() {
    const bar = document.querySelector('.bulk-actions-bar')
    if (bar) {
      const count = this.selectedFoods.size
      bar.querySelector('.selected-count').textContent = `${count} selected`
    }
  }

  toggleFoodSelection(categoryId, foodId, subgroupId = null) {
    const key = subgroupId ? `${categoryId}-${subgroupId}-${foodId}` : `${categoryId}-${foodId}`

    const foodElement = subgroupId
      ? document.querySelector(
          `.food-image[data-category-id="${categoryId}"][data-subgroup-id="${subgroupId}"][data-food-id="${foodId}"]`
        )?.parentElement
      : document.querySelector(
          `.food-image[data-category-id="${categoryId}"][data-food-id="${foodId}"]`
        )?.parentElement

    if (this.selectedFoods.has(key)) {
      this.selectedFoods.delete(key)
      foodElement?.classList.remove('selected')
    } else {
      this.selectedFoods.add(key)
      foodElement?.classList.add('selected')
    }

    this.updateBulkActionsBar()
  }

  selectAllVisible() {
    const allFoodItems = document.querySelectorAll('.food-item:not(.filtered-out)')

    allFoodItems.forEach((item) => {
      const img = item.querySelector('.food-image')
      if (img) {
        const categoryId = img.dataset.categoryId
        const foodId = img.dataset.foodId
        const subgroupId = img.dataset.subgroupId

        if (categoryId && foodId) {
          const key = subgroupId
            ? `${categoryId}-${subgroupId}-${foodId}`
            : `${categoryId}-${foodId}`
          this.selectedFoods.add(key)
          item.classList.add('selected')
        }
      }
    })

    this.updateBulkActionsBar()
  }

  unselectAll() {
    this.selectedFoods.clear()
    document.querySelectorAll('.food-item.selected').forEach((item) => {
      item.classList.remove('selected')
    })
    this.updateBulkActionsBar()
  }

  bulkDelete() {
    const count = this.selectedFoods.size
    if (count === 0) return

    const message = `Are you sure you want to delete ${count} selected food${count > 1 ? 's' : ''}?`

    this.modalManager.showConfirmation(message, async () => {
      for (const key of this.selectedFoods) {
        const parts = key.split('-')

        if (parts.length === 3) {
          // Format: categoryId-subgroupId-foodId
          const [categoryId, subgroupId, foodId] = parts.map(Number)
          const category = this.categories.find((c) => c.id === categoryId)

          if (category && category.subgroups) {
            const subgroup = category.subgroups.find((s) => s.id === subgroupId)
            if (subgroup) {
              const food = subgroup.foods.find((f) => f.id === foodId)
              if (food && food.imageUrl && !food.imageUrl.startsWith('data:')) {
                await this.dataManager.deleteImage(food.imageUrl)
              }
              subgroup.foods = subgroup.foods.filter((f) => f.id !== foodId)
            }
          }
        } else if (parts.length === 2) {
          // Format: categoryId-foodId (direct foods)
          const [categoryId, foodId] = parts.map(Number)
          const category = this.categories.find((c) => c.id === categoryId)

          if (category) {
            const food = category.foods.find((f) => f.id === foodId)
            if (food && food.imageUrl && !food.imageUrl.startsWith('data:')) {
              await this.dataManager.deleteImage(food.imageUrl)
            }
            category.foods = category.foods.filter((f) => f.id !== foodId)
          }
        }
      }

      await this.saveAllData()
      this.uiManager.renderCategories(this.categories, this.isEditMode)
      this.toggleBulkSelectMode()
    })
  }

  editFood() {
    if (!this.currentFoodId) return

    let food = null
    let categoryId = this.currentCategoryId
    let subgroupId = this.currentSubgroupId

    this.editingFoodId = this.currentFoodId
    this.editingCategoryId = this.currentCategoryId
    this.editingSubgroupId = this.currentSubgroupId

    if (subgroupId && categoryId) {
      // Food is in a subgroup
      const category = this.categories.find((c) => c.id === categoryId)
      if (category && category.subgroups) {
        const subgroup = category.subgroups.find((s) => s.id === subgroupId)
        food = subgroup?.foods.find((f) => f.id === this.currentFoodId)
      }
    } else if (categoryId) {
      // Food is in direct category
      const category = this.categories.find((c) => c.id === categoryId)
      food = category?.foods.find((f) => f.id === this.currentFoodId)
    } else {
      // Food is in root level
      food = this.foods.find((f) => f.id === this.currentFoodId)
    }

    if (!food) return

    this.populateEditForm(food)
    this.modalManager.showEditFood()
  }

  populateEditForm(food) {
    document.getElementById('editFoodName').value = food.name || ''
    document.getElementById('editFoodNotes').value = food.notes || ''
    document.getElementById('editFoodSpecificData').value = food.specificData || ''

    const previewDiv = document.getElementById('currentImagePreview')
    if (food.imageUrl) {
      previewDiv.innerHTML = `
      <img src="${food.imageUrl}" style="width: 100px; height: 100px; object-fit: cover; border: 1px solid #ddd; border-radius: 4px;">
      <p style="font-size: 12px; color: #666; margin: 5px 0;">Current image (upload new to replace)</p>
    `
    } else {
      previewDiv.innerHTML = ''
    }

    if (food.nutrition) {
      document.getElementById('editNutritionProtein').value =
        food.nutrition.protein !== null && food.nutrition.protein !== undefined
          ? food.nutrition.protein
          : ''
      document.getElementById('editNutritionFat').value =
        food.nutrition.fat !== null && food.nutrition.fat !== undefined ? food.nutrition.fat : ''
      document.getElementById('editNutritionCarbs').value =
        food.nutrition.carbs !== null && food.nutrition.carbs !== undefined
          ? food.nutrition.carbs
          : ''
      document.getElementById('editNutritionFiber').value =
        food.nutrition.fiber !== null && food.nutrition.fiber !== undefined
          ? food.nutrition.fiber
          : ''
      document.getElementById('editNutritionSugar').value =
        food.nutrition.sugar !== null && food.nutrition.sugar !== undefined
          ? food.nutrition.sugar
          : ''
      document.getElementById('editNutritionSodium').value =
        food.nutrition.sodium !== null && food.nutrition.sodium !== undefined
          ? food.nutrition.sodium
          : ''
    }

    this.uiManager.renderTagsForEdit(this.tags, food.tags)
  }

  hideEditFoodForm() {
    this.modalManager.hideEditFood()
    document.getElementById('editFoodImage').value = ''
    document.getElementById('currentImagePreview').innerHTML = ''
    this.editingSubgroupId = null
  }

  async updateFood() {
    const formData = this.uiManager.getEditFoodFormData()

    if (!formData.name) {
      this.uiManager.showError('editFoodNameError', 'Please enter food name')
      this.uiManager.focusElement('editFoodName')
      return
    }

    this.uiManager.hideError('editFoodNameError')

    let food = null
    let category = null
    let subgroup = null

    if (this.editingSubgroupId && this.editingCategoryId) {
      // Food is in a subgroup
      category = this.categories.find((c) => c.id === this.editingCategoryId)
      if (category && category.subgroups) {
        subgroup = category.subgroups.find((s) => s.id === this.editingSubgroupId)
        food = subgroup?.foods.find((f) => f.id === this.editingFoodId)
      }
    } else if (this.editingCategoryId) {
      // Food is in direct category
      category = this.categories.find((c) => c.id === this.editingCategoryId)
      food = category?.foods.find((f) => f.id === this.editingFoodId)
    } else {
      // Food is in root level
      food = this.foods.find((f) => f.id === this.editingFoodId)
    }

    if (!food) {
      return
    }

    const updateBtn = document.getElementById('updateFoodBtn')
    const originalText = updateBtn.textContent
    updateBtn.disabled = true
    updateBtn.textContent = 'Updating...'

    let imageUrl = food.imageUrl
    if (formData.image) {
      if (food.imageUrl && !food.imageUrl.startsWith('data:')) {
        await this.dataManager.deleteImage(food.imageUrl)
      }
      const imageResult = await this.dataManager.saveImage(formData.image)
      if (imageResult.success) {
        imageUrl = imageResult.path
      }
    }

    food.name = formData.name
    food.imageUrl = imageUrl
    food.notes = formData.notes
    food.nutrition = formData.nutrition
    food.specificData = formData.specificData
    food.tags = formData.tags

    updateBtn.disabled = false
    updateBtn.textContent = originalText

    await this.saveAllData()
    this.uiManager.renderCategories(this.categories, this.isEditMode)

    let updatedFood = null
    if (this.editingSubgroupId && this.editingCategoryId) {
      const category = this.categories.find((c) => c.id === this.editingCategoryId)
      if (category && category.subgroups) {
        const subgroup = category.subgroups.find((s) => s.id === this.editingSubgroupId)
        updatedFood = subgroup?.foods.find((f) => f.id === this.editingFoodId)
      }
    } else if (this.editingCategoryId) {
      const category = this.categories.find((c) => c.id === this.editingCategoryId)
      updatedFood = category?.foods.find((f) => f.id === this.editingFoodId)
    } else {
      updatedFood = this.foods.find((f) => f.id === this.editingFoodId)
    }

    this.hideEditFoodForm()

    if (updatedFood) {
      this.uiManager.showFoodDetails(updatedFood, this.tags)
    }

    this.editingFoodId = null
    this.editingCategoryId = null
    this.editingSubgroupId = null
  }
}

const dietHelper = new DietHelper()
window.dietHelper = dietHelper

ui.js:
import { CONFIG } from './config.js'

export class UIManager {
  constructor() {
    this.elements = {
      categoriesContainer: document.getElementById('categoriesContainer'),
      tagsList: document.getElementById('tagsList'),
      existingTags: document.getElementById('existingTags'),
      detailsImage: document.getElementById('detailsImage'),
      detailsName: document.getElementById('detailsName'),
      detailsTags: document.getElementById('detailsTags'),
    }

    this.eventListeners = new Map()
    this.currentFoodElements = []
    this.currentTagElements = []
  }

  addEventListenerWithCleanup(element, event, handler, identifier) {
    this.removeEventListener(identifier)
    element.addEventListener(event, handler)
    this.eventListeners.set(identifier, {
      element,
      event,
      handler,
    })
  }

  removeEventListener(identifier) {
    const listener = this.eventListeners.get(identifier)
    if (listener) {
      listener.element.removeEventListener(listener.event, listener.handler)
      this.eventListeners.delete(identifier)
    }
  }

  cleanup() {
    this.eventListeners.forEach((listener, identifier) => {
      listener.element.removeEventListener(listener.event, listener.handler)
    })
    this.eventListeners.clear()
    this.currentFoodElements = []
    this.currentTagElements = []
  }

  renderCategories(categories, isEditMode = false) {
    this.cleanup()
    this.elements.categoriesContainer.innerHTML = ''

    categories.forEach((category) => {
      const categoryDiv = document.createElement('div')
      categoryDiv.className = 'category-container'
      categoryDiv.style.cssText =
        'border: 1px solid #ccc; margin: 10px; padding: 10px; padding-top:2px'

      const headerDiv = document.createElement('div')
      headerDiv.className = 'category-header'
      headerDiv.style.cssText = 'display: flex; justify-content: space-between; margin-bottom: 3px;'

      const actualEditMode = window.dietHelper ? window.dietHelper.isEditMode : isEditMode

      headerDiv.innerHTML = `
      <span id="categoryName-${category.id}" 
        style="font-weight: bold; font-size: 16px;">${this.escapeHtml(category.name)}</span>
      <div style="display: flex; gap: 5px; align-items: center;">
        <button onclick="window.dietHelper.startRenameCategory(${category.id})" style="padding: 5px 10px; display: ${actualEditMode ? 'inline-block' : 'none'};">Rename</button>
        <button onclick="window.dietHelper.deleteCategory(${category.id})" style="padding: 5px 10px; display: ${actualEditMode ? 'inline-block' : 'none'};">Delete</button>
        <button onclick="window.dietHelper.showAddFoodForm(${category.id})" style="padding: 5px 15px; font-size: 16px; font-weight: bold;">+</button>
      </div>
    `

      categoryDiv.appendChild(headerDiv)

      if (category.subgroups && category.subgroups.length > 0) {
        const subgroupsGrid = document.createElement('div')
        subgroupsGrid.style.cssText =
          'display: grid; grid-template-columns: 1fr 1fr; gap: 6px; margin: 10px 5px;'

        category.subgroups.forEach((subgroup) => {
          const subgroupDiv = document.createElement('div')
          subgroupDiv.className = 'subgroup-container'
          subgroupDiv.id = `subgroup-${subgroup.id}`

          const subgroupHeader = document.createElement('div')
          subgroupHeader.className = 'subgroup-header'

          subgroupHeader.innerHTML = `
      <span id="subgroupName-${subgroup.id}" style="font-weight: bold; font-size: 14px;">${this.escapeHtml(subgroup.name)}</span>
      <div style="display: flex; gap: 5px; align-items: center;">
        <button onclick="window.dietHelper.startRenameSubgroup(${category.id}, ${subgroup.id})" style="padding: 3px 8px; font-size: 12px; display: ${actualEditMode ? 'inline-block' : 'none'};">Rename</button>
        <button onclick="window.dietHelper.deleteSubgroup(${category.id}, ${subgroup.id})" style="padding: 3px 8px; font-size: 12px; display: ${actualEditMode ? 'inline-block' : 'none'};">Delete</button>
        <button onclick="window.dietHelper.showAddFoodToSubgroup(${category.id}, ${subgroup.id})" style="padding: 3px 10px; font-size: 14px; font-weight: bold;">+</button>
      </div>
    `

          subgroupDiv.appendChild(subgroupHeader)

          const subgroupFoodsDiv = document.createElement('div')
          subgroupFoodsDiv.className = 'subgroup-foods'
          subgroupFoodsDiv.id = `subgroup-foods-${subgroup.id}`
          subgroupFoodsDiv.style.cssText =
            'display: flex; flex-wrap: wrap; position: relative; min-height: 60px;'

          if (subgroup.foods.length === 0) {
            subgroupFoodsDiv.innerHTML =
              '<p class="empty-subgroup-message" style="color: #999; font-size: 12px; margin: 10px; position: absolute; width: 100%; text-align: center; pointer-events: none;">No foods in this subgroup</p>'
          } else {
            subgroup.foods.forEach((food) => {
              const foodDiv = document.createElement('div')
              foodDiv.className = 'food-item'

              foodDiv.innerHTML = `
              ${
                food.imageUrl
                  ? `<img src="${food.imageUrl}" class="food-image" data-category-id="${category.id}" data-subgroup-id="${subgroup.id}" data-food-id="${food.id}">`
                  : `<div class="food-image no-image" data-category-id="${category.id}" data-subgroup-id="${subgroup.id}" data-food-id="${food.id}">No Image</div>`
              }
              <div class="food-name">${this.escapeHtml(food.name)}</div>
            `

              const imageElement = foodDiv.querySelector('.food-image')
              const listenerId = `food-image-${category.id}-${subgroup.id}-${food.id}`

              const clickHandler = (e) => {
                if (window.dietHelper.isBulkSelectMode) {
                  e.preventDefault()
                  e.stopPropagation()
                  window.dietHelper.toggleFoodSelection(category.id, food.id, subgroup.id)
                } else if (!window.dietHelper.isEditMode) {
                  // Only show details if not in edit mode
                  window.dietHelper.showSubgroupFoodDetails(category.id, subgroup.id, food.id)
                }
              }

              this.addEventListenerWithCleanup(foodDiv, 'click', clickHandler, listenerId)
              this.currentFoodElements.push(listenerId)

              subgroupFoodsDiv.appendChild(foodDiv)
            })
          }

          subgroupDiv.appendChild(subgroupFoodsDiv)
          subgroupsGrid.appendChild(subgroupDiv)
        })
        categoryDiv.appendChild(subgroupsGrid)
      }

      if (actualEditMode) {
        const addSubgroupBtn = document.createElement('button')
        addSubgroupBtn.textContent = '+ Add Subgroup'
        addSubgroupBtn.style.cssText =
          'margin: 10px; padding: 5px 15px; background: #e9ecef; border: 1px solid #ddd; border-radius: 4px; cursor: pointer;'
        addSubgroupBtn.onclick = () => window.dietHelper.showAddSubgroupForm(category.id)
        categoryDiv.appendChild(addSubgroupBtn)
      }

      const foodsDiv = document.createElement('div')
      foodsDiv.id = `foods-${category.id}`
      const needsMinHeight =
        !category.subgroups || category.subgroups.length === 0 || category.foods.length > 0
      foodsDiv.style.cssText = `display: flex; flex-wrap: wrap; margin: 10px 0; position: relative; ${needsMinHeight ? 'min-height: 80px;' : ''}`

      if (category.foods.length === 0 && (!category.subgroups || category.subgroups.length === 0)) {
        foodsDiv.innerHTML =
          '<p class="empty-category-message" style="color: #666; margin: 40px 0; position: absolute; width: 100%; text-align: center; pointer-events: none;">No foods in this category</p>'
      } else if (
        category.foods.length === 0 &&
        category.subgroups &&
        category.subgroups.length > 0
      ) {
        foodsDiv.style.display = 'none'
      } else if (category.foods.length > 0) {
        const directFoodsLabel = document.createElement('div')
        directFoodsLabel.style.cssText = 'width: 100%; font-size: 12px; color: #666; margin: 5px 0;'
        directFoodsLabel.textContent = 'Direct foods:'
        foodsDiv.appendChild(directFoodsLabel)

        category.foods.forEach((food) => {
          const foodDiv = document.createElement('div')
          foodDiv.className = 'food-item'

          foodDiv.innerHTML = `
          ${
            food.imageUrl
              ? `<img src="${food.imageUrl}" class="food-image" data-category-id="${category.id}" data-food-id="${food.id}">`
              : `<div class="food-image no-image" data-category-id="${category.id}" data-food-id="${food.id}">No Image</div>`
          }
          <div class="food-name">${this.escapeHtml(food.name)}</div>
        `

          const imageElement = foodDiv.querySelector('.food-image')
          const listenerId = `food-image-${category.id}-${food.id}`

          const clickHandler = (e) => {
            if (window.dietHelper.isBulkSelectMode) {
              e.preventDefault()
              e.stopPropagation()
              window.dietHelper.toggleFoodSelection(category.id, food.id)
            } else {
              if (e.target.classList.contains('food-image')) {
                window.dietHelper.showCategoryFoodDetails(category.id, food.id)
              }
            }
          }

          this.addEventListenerWithCleanup(foodDiv, 'click', clickHandler, listenerId)
          this.currentFoodElements.push(listenerId)

          foodsDiv.appendChild(foodDiv)
        })
      }

      categoryDiv.appendChild(foodsDiv)
      this.elements.categoriesContainer.appendChild(categoryDiv)
    })

    if (window.dietHelper && window.dietHelper.applyFilters) {
      window.dietHelper.applyFilters()
    }

    if (window.dietHelper && window.dietHelper.isBulkSelectMode) {
      const container = document.getElementById('categoriesContainer')
      container.classList.add('bulk-select-mode')

      window.dietHelper.selectedFoods.forEach((key) => {
        const [categoryId, foodId] = key.split('-')
        const foodElement = document.querySelector(
          `.food-image[data-category-id="${categoryId}"][data-food-id="${foodId}"]`
        )?.parentElement
        if (foodElement) {
          foodElement.classList.add('selected')
        }
      })
    }
  }

  renderTagsForSelection(tags) {
    this.elements.tagsList.innerHTML = ''

    if (tags.length === 0) {
      const noTagsMsg = document.createElement('p')
      noTagsMsg.textContent = 'No tags available. Add some tags first!'
      noTagsMsg.style.color = '#666'
      noTagsMsg.style.fontSize = '12px'
      this.elements.tagsList.appendChild(noTagsMsg)
      return
    }

    const tagsContainer = document.createElement('div')
    tagsContainer.style.cssText = 'display: flex; flex-wrap: wrap; gap: 8px;'

    tags.forEach((tag) => {
      const tagButton = document.createElement('div')
      tagButton.className = 'selectable-tag'
      tagButton.dataset.tagId = tag.id
      tagButton.textContent = this.escapeHtml(tag.name)

      tagButton.addEventListener('click', () => {
        tagButton.classList.toggle('selected')
      })

      tagsContainer.appendChild(tagButton)
    })

    this.elements.tagsList.appendChild(tagsContainer)
  }

  renderExistingTags(tags) {
    this.currentTagElements.forEach((identifier) => {
      this.removeEventListener(identifier)
    })
    this.currentTagElements = []

    this.elements.existingTags.innerHTML = ''

    if (tags.length === 0) {
      const noTagsMsg = document.createElement('p')
      noTagsMsg.textContent = 'No tags created yet.'
      noTagsMsg.style.color = '#666'
      noTagsMsg.style.fontSize = '12px'
      this.elements.existingTags.appendChild(noTagsMsg)
      return
    }

    const tagsGrid = document.createElement('div')
    tagsGrid.style.cssText = 'display: grid; grid-template-columns: 1fr 1fr; gap: 10px;'

    tags.forEach((tag) => {
      const tagDiv = document.createElement('div')
      tagDiv.className = 'tag-item'
      tagDiv.style.cssText =
        'display: flex; justify-content: space-between; align-items: center; padding: 8px 10px; border: 1px solid #ddd; border-radius: 5px;'

      const tagName = document.createElement('span')
      tagName.textContent = this.escapeHtml(tag.name)
      tagName.style.cssText =
        'flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;'

      const deleteBtn = document.createElement('button')
      deleteBtn.className = 'delete-tag-btn'
      deleteBtn.setAttribute('data-tag-id', tag.id)
      deleteBtn.textContent = '‚àí'
      deleteBtn.style.cssText =
        'width: 24px; height: 24px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 18px; line-height: 1; padding: 0; display: flex; align-items: center; justify-content: center; flex-shrink: 0;'

      deleteBtn.onmouseover = () => {
        deleteBtn.style.background = '#c82333'
      }
      deleteBtn.onmouseout = () => {
        deleteBtn.style.background = '#dc3545'
      }

      tagDiv.appendChild(tagName)
      tagDiv.appendChild(deleteBtn)

      const clickHandler = () => {
        window.dietHelper.deleteTag(tag.id)
      }

      const listenerId = `delete-tag-${tag.id}`
      this.addEventListenerWithCleanup(deleteBtn, 'click', clickHandler, listenerId)
      this.currentTagElements.push(listenerId)

      tagsGrid.appendChild(tagDiv)
    })

    this.elements.existingTags.appendChild(tagsGrid)
  }

  showFoodDetails(food, tags) {
    const tagNames = food.tags
      .map((tagId) => {
        const tag = tags.find((t) => t.id === tagId)
        return tag ? tag.name : ''
      })
      .filter((name) => name)

    this.elements.detailsName.textContent = food.name

    this.elements.detailsImage.src = food.imageUrl || ''
    this.elements.detailsImage.style.display = food.imageUrl ? 'block' : 'none'

    if (!food.imageUrl) {
      this.elements.detailsImage.style.display = 'block'
      this.elements.detailsImage.src =
        'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSIjZjBmMGYwIi8+PHRleHQgeD0iNTAlIiB5PSI1MCUiIGZvbnQtZmFtaWx5PSJBcmlhbCIgZm9udC1zaXplPSIxNCIgZmlsbD0iIzk5OSIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZHk9Ii4zZW0iPk5vIEltYWdlPC90ZXh0Pjwvc3ZnPg=='
    }

    const tagsContainer = document.getElementById('detailsTags')
    if (tagNames.length > 0) {
      tagsContainer.textContent = tagNames.join(', ')
      tagsContainer.style.color = '#495057'
    } else {
      tagsContainer.innerHTML = '<span style="color: #999; font-style: italic;">No tags</span>'
    }

    const notesElement = document.getElementById('detailsNotes')
    if (food.notes) {
      notesElement.textContent = food.notes
      notesElement.style.fontStyle = 'normal'
      notesElement.style.color = '#555'
    } else {
      notesElement.textContent = 'No notes added'
      notesElement.style.fontStyle = 'italic'
      notesElement.style.color = '#999'
    }

    const hasNutrition = food.nutrition && typeof food.nutrition === 'object'

    if (hasNutrition) {
      const proteinEl = document.getElementById('detailsProtein')
      const fatEl = document.getElementById('detailsFat')
      const carbsEl = document.getElementById('detailsCarbs')
      const fiberEl = document.getElementById('detailsFiber')
      const sugarEl = document.getElementById('detailsSugar')
      const sodiumEl = document.getElementById('detailsSodium')

      if (proteinEl)
        proteinEl.textContent =
          food.nutrition.protein !== null && food.nutrition.protein !== undefined
            ? `${food.nutrition.protein}g`
            : '-'
      if (fatEl)
        fatEl.textContent =
          food.nutrition.fat !== null && food.nutrition.fat !== undefined
            ? `${food.nutrition.fat}g`
            : '-'
      if (carbsEl)
        carbsEl.textContent =
          food.nutrition.carbs !== null && food.nutrition.carbs !== undefined
            ? `${food.nutrition.carbs}g`
            : '-'
      if (fiberEl)
        fiberEl.textContent =
          food.nutrition.fiber !== null && food.nutrition.fiber !== undefined
            ? `${food.nutrition.fiber}g`
            : '-'
      if (sugarEl)
        sugarEl.textContent =
          food.nutrition.sugar !== null && food.nutrition.sugar !== undefined
            ? `${food.nutrition.sugar}g`
            : '-'
      if (sodiumEl)
        sodiumEl.textContent =
          food.nutrition.sodium !== null && food.nutrition.sodium !== undefined
            ? `${food.nutrition.sodium}mg`
            : '-'
    } else {
      const elements = [
        'detailsProtein',
        'detailsFat',
        'detailsCarbs',
        'detailsFiber',
        'detailsSugar',
        'detailsSodium',
      ]
      elements.forEach((id) => {
        const el = document.getElementById(id)
        if (el) el.textContent = '-'
      })
    }

    const specificElement = document.getElementById('detailsSpecificData')
    if (food.specificData) {
      specificElement.textContent = food.specificData
      specificElement.style.fontStyle = 'normal'
      specificElement.style.color = '#555'
    } else {
      specificElement.textContent = 'No specific information added'
      specificElement.style.fontStyle = 'italic'
      specificElement.style.color = '#999'
    }
  }

  clearFoodForm() {
    const nameField = document.getElementById('foodName')
    const imageField = document.getElementById('foodImage')
    const errorDiv = document.getElementById('foodNameError')
    const notesField = document.getElementById('foodNotes')
    const specificDataField = document.getElementById('foodSpecificData')

    if (nameField) nameField.value = ''
    if (imageField) imageField.value = ''
    if (errorDiv) errorDiv.classList.add('hidden')
    if (notesField) notesField.value = ''
    if (specificDataField) specificDataField.value = ''

    const nutritionFields = ['Protein', 'Fat', 'Carbs', 'Fiber', 'Sugar', 'Sodium']
    nutritionFields.forEach((field) => {
      const input = document.getElementById(`nutrition${field}`)
      if (input) input.value = ''
    })

    const selectedTags = document.querySelectorAll('.selectable-tag.selected')
    selectedTags.forEach((tag) => tag.classList.remove('selected'))
  }

  clearTagForm() {
    const tagField = document.getElementById('newTagName')
    const errorDiv = document.getElementById('tagNameError')

    if (tagField) tagField.value = ''
    if (errorDiv) errorDiv.classList.add('hidden')
  }

  showError(elementId, message = null) {
    const errorDiv = document.getElementById(elementId)
    if (errorDiv) {
      const errorMessage = message || CONFIG.MESSAGES.ERRORS.FOOD_NAME_REQUIRED
      errorDiv.textContent = errorMessage
      errorDiv.classList.remove('hidden')
    }
  }

  hideError(elementId) {
    const errorDiv = document.getElementById(elementId)
    if (errorDiv) {
      errorDiv.classList.add('hidden')
    }
  }

  getSelectedEditTags() {
    const selectedTags = []
    const selectedElements = document.querySelectorAll('#editTagsList .selectable-tag.selected')
    selectedElements.forEach((el) => {
      selectedTags.push(parseInt(el.dataset.tagId))
    })
    return selectedTags
  }

  getFoodFormData() {
    return {
      name: document.getElementById('foodName')?.value.trim() || '',
      image: document.getElementById('foodImage')?.files[0] || null,
      tags: this.getSelectedFoodTags(),
      notes: document.getElementById('foodNotes')?.value.trim() || '',
      nutrition: {
        protein:
          document.getElementById('nutritionProtein')?.value !== ''
            ? parseFloat(document.getElementById('nutritionProtein').value)
            : null,
        fat:
          document.getElementById('nutritionFat')?.value !== ''
            ? parseFloat(document.getElementById('nutritionFat').value)
            : null,
        carbs:
          document.getElementById('nutritionCarbs')?.value !== ''
            ? parseFloat(document.getElementById('nutritionCarbs').value)
            : null,
        fiber:
          document.getElementById('nutritionFiber')?.value !== ''
            ? parseFloat(document.getElementById('nutritionFiber').value)
            : null,
        sugar:
          document.getElementById('nutritionSugar')?.value !== ''
            ? parseFloat(document.getElementById('nutritionSugar').value)
            : null,
        sodium:
          document.getElementById('nutritionSodium')?.value !== ''
            ? parseFloat(document.getElementById('nutritionSodium').value)
            : null,
      },
      specificData: document.getElementById('foodSpecificData')?.value.trim() || '',
    }
  }

  renderTagsForEdit(tags, selectedTagIds = []) {
    const container = document.getElementById('editTagsList')
    container.innerHTML = ''

    if (tags.length === 0) {
      const noTagsMsg = document.createElement('p')
      noTagsMsg.textContent = 'No tags available. Add some tags first!'
      noTagsMsg.style.color = '#666'
      noTagsMsg.style.fontSize = '12px'
      container.appendChild(noTagsMsg)
      return
    }

    const tagsContainer = document.createElement('div')
    tagsContainer.style.cssText = 'display: flex; flex-wrap: wrap; gap: 8px;'

    tags.forEach((tag) => {
      const tagButton = document.createElement('div')
      tagButton.className = 'selectable-tag'
      tagButton.dataset.tagId = tag.id
      tagButton.textContent = this.escapeHtml(tag.name)

      if (selectedTagIds.includes(tag.id)) {
        tagButton.classList.add('selected')
      }

      tagButton.addEventListener('click', () => {
        tagButton.classList.toggle('selected')
      })

      tagsContainer.appendChild(tagButton)
    })

    container.appendChild(tagsContainer)
  }

  getEditFoodFormData() {
    return {
      name: document.getElementById('editFoodName')?.value.trim() || '',
      image: document.getElementById('editFoodImage')?.files[0] || null,
      tags: this.getSelectedEditTags(),
      notes: document.getElementById('editFoodNotes')?.value.trim() || '',
      nutrition: {
        protein:
          document.getElementById('editNutritionProtein')?.value !== ''
            ? parseFloat(document.getElementById('editNutritionProtein').value)
            : null,
        fat:
          document.getElementById('editNutritionFat')?.value !== ''
            ? parseFloat(document.getElementById('editNutritionFat').value)
            : null,
        carbs:
          document.getElementById('editNutritionCarbs')?.value !== ''
            ? parseFloat(document.getElementById('editNutritionCarbs').value)
            : null,
        fiber:
          document.getElementById('editNutritionFiber')?.value !== ''
            ? parseFloat(document.getElementById('editNutritionFiber').value)
            : null,
        sugar:
          document.getElementById('editNutritionSugar')?.value !== ''
            ? parseFloat(document.getElementById('editNutritionSugar').value)
            : null,
        sodium:
          document.getElementById('editNutritionSodium')?.value !== ''
            ? parseFloat(document.getElementById('editNutritionSodium').value)
            : null,
      },
      specificData: document.getElementById('editFoodSpecificData')?.value.trim() || '',
    }
  }

  getTagFormData() {
    return {
      name: document.getElementById('newTagName')?.value.trim() || '',
    }
  }

  escapeHtml(text) {
    const div = document.createElement('div')
    div.textContent = text
    return div.innerHTML
  }

  showLoading(elementId, message = 'Loading...') {
    const element = document.getElementById(elementId)
    if (element) {
      element.innerHTML = `<p style="text-align: center; color: #666;">${message}</p>`
    }
  }

  focusElement(elementId) {
    const element = document.getElementById(elementId)
    if (element) {
      setTimeout(() => element.focus(), 100)
    }
  }

  getSelectedFoodTags() {
    const selectedTags = []
    const selectedElements = document.querySelectorAll('#tagsList .selectable-tag.selected')
    selectedElements.forEach((el) => {
      selectedTags.push(parseInt(el.dataset.tagId))
    })
    return selectedTags
  }

  destroy() {
    this.cleanup()
  }
}

data.js:

import { CONFIG, ConfigUtils } from './config.js'

export class DataManager {
  constructor() {
    this.dataFile = CONFIG.FILES.DATA_FILE
    this.imagesDir = CONFIG.FILES.IMAGES_DIR
    this.hiddenCanvas = null
  }

  async saveData(data) {
    try {
      if (typeof require !== 'undefined') {
        const { ipcRenderer } = require('electron')
        const result = await ipcRenderer.invoke('save-data', data)
        return result
      } else {
        localStorage.setItem(CONFIG.STORAGE.MAIN_DATA, JSON.stringify(data))
        return { success: true }
      }
    } catch (error) {
      console.error('Error saving data:', error)
      return { success: false, error: error.message }
    }
  }

  async loadData() {
    try {
      if (typeof require !== 'undefined') {
        const { ipcRenderer } = require('electron')
        const data = await ipcRenderer.invoke('load-data')
        return {
          success: true,
          data: {
            foods: data.foods || [],
            tags: data.tags || [],
            categories: data.categories || [],
          },
        }
      } else {
        const data = JSON.parse(localStorage.getItem(CONFIG.STORAGE.MAIN_DATA) || '{}')
        return {
          success: true,
          data: {
            foods: data.foods || [],
            tags: data.tags || [],
            categories: data.categories || [],
          },
        }
      }
    } catch (error) {
      console.error('Error loading data:', error)
      return {
        success: false,
        data: { foods: [], tags: [], categories: [] },
        error: error.message,
      }
    }
  }

  async saveImage(imageFile) {
    try {
      if (!imageFile) {
        return { success: false, error: 'No image file provided' }
      }

      const validation = ConfigUtils.validateImage(imageFile)
      if (!validation.valid) {
        return { success: false, error: validation.error }
      }

      if (typeof require !== 'undefined') {
        const reader = new FileReader()

        return new Promise((resolve) => {
          reader.onload = async (e) => {
            try {
              const { ipcRenderer } = require('electron')
              const fileName = `food_${Date.now()}.${imageFile.name.split('.').pop()}`
              const result = await ipcRenderer.invoke('save-image', e.target.result, fileName)
              resolve(result)
            } catch (error) {
              resolve({ success: false, error: error.message })
            }
          }
          reader.readAsDataURL(imageFile)
        })
      } else {
        return new Promise((resolve) => {
          const reader = new FileReader()
          reader.onload = (e) => {
            try {
              const base64Data = e.target.result
              if (CONFIG.FEATURES.IMAGE_COMPRESSION && base64Data.length > 500000) {
                this.compressImage(base64Data, imageFile.type)
                  .then((compressedData) => {
                    resolve({ success: true, path: compressedData })
                  })
                  .catch((error) => {
                    console.warn('Image compression failed, using original:', error)
                    resolve({ success: true, path: base64Data })
                  })
              } else {
                resolve({ success: true, path: base64Data })
              }
            } catch (error) {
              resolve({ success: false, error: error.message })
            }
          }
          reader.onerror = () => {
            resolve({ success: false, error: 'Failed to read image file' })
          }
          reader.readAsDataURL(imageFile)
        })
      }
    } catch (error) {
      console.error('Error saving image:', error)
      return { success: false, error: error.message }
    }
  }

  async deleteImage(imagePath) {
    try {
      if (!imagePath) return { success: true }

      if (typeof require !== 'undefined') {
        try {
          const { ipcRenderer } = require('electron')
          const result = await ipcRenderer.invoke('delete-image', imagePath)
          return result
        } catch (electronError) {
          console.warn('Image deletion not implemented in Electron main process')
          return { success: true, warning: 'Image handler not registered' }
        }
      } else {
        return { success: true }
      }
    } catch (error) {
      console.error('Error deleting image:', error)
      return { success: true, warning: 'Image file could not be deleted' }
    }
  }

  async compressImage(base64Data, mimeType) {
    return new Promise((resolve, reject) => {
      if (!this.hiddenCanvas) {
        this.hiddenCanvas = document.createElement('canvas')
        this.hiddenCanvas.style.cssText = `
                position: absolute;
                left: -9999px;
                top: -9999px;
                visibility: hidden;
            `
        document.body.appendChild(this.hiddenCanvas)
      }

      const canvas = this.hiddenCanvas
      const ctx = canvas.getContext('2d')
      const img = new Image()

      img.onload = () => {
        const maxWidth = 800
        const maxHeight = 600
        let { width, height } = img

        if (width > height) {
          if (width > maxWidth) {
            height = (height * maxWidth) / width
            width = maxWidth
          }
        } else {
          if (height > maxHeight) {
            width = (width * maxHeight) / height
            height = maxHeight
          }
        }

        canvas.width = width
        canvas.height = height

        ctx.drawImage(img, 0, 0, width, height)
        const compressedData = canvas.toDataURL(mimeType || 'image/jpeg', CONFIG.IMAGES.QUALITY)
        resolve(compressedData)
      }

      img.onerror = () => reject(new Error('Failed to load image for compression'))
      img.src = base64Data
    })
  }

  validateFood(foodData) {
    const errors = []

    const nameValidation = ConfigUtils.validateFoodName(foodData.name)
    if (!nameValidation.valid) {
      errors.push(nameValidation.error)
    }

    if (!foodData.id || typeof foodData.id !== 'number') {
      errors.push('Food ID is required and must be a number')
    }

    if (foodData.tags && !Array.isArray(foodData.tags)) {
      errors.push('Tags must be an array')
    }

    if (foodData.tags && foodData.tags.length > CONFIG.VALIDATION.MAX_TAGS_PER_FOOD) {
      errors.push(CONFIG.MESSAGES.ERRORS.MAX_TAGS_PER_FOOD)
    }

    return {
      isValid: errors.length === 0,
      errors: errors,
    }
  }

  validateTag(tagData) {
    const errors = []

    const nameValidation = ConfigUtils.validateTagName(tagData.name)
    if (!nameValidation.valid) {
      errors.push(nameValidation.error)
    }

    if (!tagData.id || typeof tagData.id !== 'number') {
      errors.push('Tag ID is required and must be a number')
    }

    return {
      isValid: errors.length === 0,
      errors: errors,
    }
  }

  async createBackup() {
    try {
      const loadResult = await this.loadData()
      if (!loadResult.success) {
        return { success: false, error: 'Failed to load current data for backup' }
      }

      const backupData = {
        ...loadResult.data,
        backupDate: new Date().toISOString(),
      }

      if (typeof require !== 'undefined') {
        const { ipcRenderer } = require('electron')
        const backupFileName = `backup_${Date.now()}.json`
        return { success: true, message: 'Backup feature needs IPC handler implementation' }
      } else {
        localStorage.setItem(
          `${CONFIG.STORAGE.BACKUP_PREFIX}${Date.now()}`,
          JSON.stringify(backupData)
        )
        return { success: true, message: 'Backup created in localStorage' }
      }
    } catch (error) {
      console.error('Error creating backup:', error)
      return { success: false, error: error.message }
    }
  }
}

if (typeof module !== 'undefined' && module.exports) {
  module.exports = DataManager
} else {
  window.DataManager = DataManager
}


modal.js:
import { CONFIG } from './config.js'

export class ModalManager {
  constructor() {
    this.modals = {
      foodDetails: {
        modal: document.getElementById('foodDetailsDropdown'),
        overlay: this.createOverlay('foodDetailsOverlay'),
      },
      addFood: {
        modal: document.getElementById('addFoodDropdown'),
        overlay: this.createOverlay('addFoodOverlay'),
      },
      manageTags: {
        modal: document.getElementById('manageTagsDropdown'),
        overlay: this.createOverlay('manageTagsOverlay'),
      },
      addCategory: {
        modal: document.getElementById('addCategoryDropdown'),
        overlay: this.createOverlay('addCategoryOverlay'),
      },
      confirmation: {
        modal: document.getElementById('confirmationDropdown'),
        overlay: this.createOverlay('confirmationOverlay'),
      },
      editFood: {
        modal: document.getElementById('editFoodDropdown'),
        overlay: this.createOverlay('editFoodOverlay'),
      },
      addSubgroup: {
        modal: document.getElementById('addSubgroupDropdown'),
        overlay: this.createOverlay('addSubgroupOverlay'),
      },
    }

    this.activeModal = null
    this.initializeEventListeners()
    this.replaceSharedOverlay()
  }

  createOverlay(id) {
    const overlay = document.createElement('div')
    overlay.id = id
    overlay.className = 'modal-overlay'
    overlay.style.cssText = `
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 999;
        `
    document.body.appendChild(overlay)
    return overlay
  }

  replaceSharedOverlay() {
    const oldOverlay = document.getElementById('modalOverlay')
    if (oldOverlay) {
      oldOverlay.style.display = 'none !important'
      oldOverlay.style.visibility = 'hidden'
      oldOverlay.replaceWith(oldOverlay.cloneNode(true))
    }
  }

  initializeEventListeners() {
    Object.keys(this.modals).forEach((modalType) => {
      const { overlay } = this.modals[modalType]
      if (overlay) {
        overlay.addEventListener('click', () => {
          this.closeModal(modalType)
        })
      }
    })

    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        this.closeActiveModal()
      }
    })

    Object.values(this.modals).forEach(({ modal }) => {
      if (modal) {
        modal.addEventListener('click', (e) => {
          e.stopPropagation()
        })
      }
    })
  }

  showModal(modalType) {
    if (modalType === 'editFood' && this.activeModal === 'foodDetails') {
      // Keep food details open when showing edit modal
    } else {
      this.closeActiveModal()
    }

    const { modal, overlay } = this.modals[modalType]
    if (!modal || !overlay) return

    if (modalType === 'editFood' && this.activeModal === 'foodDetails') {
      this._previousModal = this.activeModal
    }

    this.activeModal = modalType

    modal.style.width = ''
    modal.style.height = ''
    modal.style.maxWidth = '90vw'
    modal.style.maxHeight = '90vh'

    overlay.style.display = 'block'
    overlay.classList.add('active')
    modal.classList.add('active')

    document.body.style.overflow = 'hidden'

    if (CONFIG.FEATURES.ANIMATIONS_ENABLED) {
      this.animateIn(modalType)
    }
  }

  showModalStacked(modalType) {
    const { modal, overlay } = this.modals[modalType]
    if (!modal || !overlay) return

    this._previousModal = this.activeModal
    this.activeModal = modalType

    modal.style.width = ''
    modal.style.height = ''
    modal.style.maxWidth = '90vw'
    modal.style.maxHeight = '90vh'

    overlay.style.display = 'block'
    overlay.classList.add('active')
    modal.classList.add('active')

    document.body.style.overflow = 'hidden'

    if (CONFIG.FEATURES.ANIMATIONS_ENABLED) {
      this.animateIn(modalType)
    }
  }

  hideModal(modalType) {
    const { modal, overlay } = this.modals[modalType]
    if (!modal || !overlay) return

    overlay.style.display = 'none'
    overlay.classList.remove('active')
    modal.classList.remove('active')

    if (this.activeModal === modalType) {
      if (this._previousModal) {
        this.activeModal = this._previousModal
        this._previousModal = null
      } else {
        this.activeModal = null
      }
    }

    if (!this.activeModal) {
      document.body.style.overflow = 'auto'
      document.body.removeAttribute('tabIndex')
    }
  }

  hideModalStacked(modalType) {
    const { modal, overlay } = this.modals[modalType]
    if (!modal || !overlay) return

    overlay.style.display = 'none'
    overlay.classList.remove('active')
    modal.classList.remove('active')

    this.activeModal = this._previousModal || null
    this._previousModal = null

    if (!this.activeModal) {
      document.body.style.overflow = 'auto'
      document.body.removeAttribute('tabIndex')
    }
  }

  closeModal(modalType) {
    this.hideModal(modalType)
  }

  showFoodDetails() {
    this.showModal('foodDetails')
  }

  hideFoodDetails() {
    this.hideModal('foodDetails')
  }

  showAddFood() {
    this.showModal('addFood')
    setTimeout(() => {
      const nameInput = document.getElementById('foodName')
      if (nameInput) nameInput.focus()
    }, 100)
  }

  hideAddFood() {
    this.hideModal('addFood')
  }

  showManageTags() {
    this.showModal('manageTags')
    setTimeout(() => {
      const tagInput = document.getElementById('newTagName')
      if (tagInput) tagInput.focus()
    }, 100)
  }

  hideManageTags() {
    this.hideModal('manageTags')
  }

  showAddCategory() {
    this.showModal('addCategory')
    setTimeout(() => {
      const input = document.getElementById('categoryNameInput')
      if (input) input.focus()
    }, 100)
  }

  hideAddCategory() {
    this.hideModal('addCategory')
  }

  closeActiveModal() {
    if (this.activeModal) {
      this.hideModal(this.activeModal)
    }
    document.body.removeAttribute('tabIndex')
    document.body.removeAttribute('tabindex')
  }

  resetAllOverlays() {
    Object.values(this.modals).forEach(({ overlay }) => {
      if (overlay) {
        overlay.style.display = 'none'
        overlay.classList.remove('active')
      }
    })
    document.body.style.pointerEvents = ''
    document.body.style.overflow = ''
  }

  isModalOpen() {
    return this.activeModal !== null
  }

  showAddSubgroup() {
    this.showModal('addSubgroup')
    setTimeout(() => {
      const input = document.getElementById('subgroupNameInput')
      if (input) input.focus()
    }, 100)
  }

  hideAddSubgroup() {
    this.hideModal('addSubgroup')
  }

  getActiveModal() {
    return this.activeModal
  }

  showConfirmation(message, onConfirm, onCancel, title) {
    onCancel = onCancel || null
    title = title || 'Confirm Delete'

    this._confirmCallback = onConfirm
    this._cancelCallback = onCancel

    document.getElementById('confirmTitle').textContent = title
    document.getElementById('confirmMessage').textContent = message

    this.showModalStacked('confirmation')

    const yesBtn = document.getElementById('confirmYesBtn')
    const noBtn = document.getElementById('confirmNoBtn')

    const handleYes = () => {
      this.hideModalStacked('confirmation')
      if (this._confirmCallback) {
        this._confirmCallback()
      }
      cleanup()
    }

    const handleNo = () => {
      this.hideModalStacked('confirmation')
      if (this._cancelCallback) {
        this._cancelCallback()
      }
      cleanup()
    }

    const handleKeydown = (e) => {
      if (e.key === 'Enter') {
        e.preventDefault()
        handleYes()
      } else if (e.key === 'Escape') {
        e.preventDefault()
        handleNo()
      }
    }

    const cleanup = () => {
      yesBtn.removeEventListener('click', handleYes)
      noBtn.removeEventListener('click', handleNo)
      document.removeEventListener('keydown', handleKeydown)
      this._confirmCallback = null
      this._cancelCallback = null
    }

    yesBtn.addEventListener('click', handleYes)
    noBtn.addEventListener('click', handleNo)
    document.addEventListener('keydown', handleKeydown)

    setTimeout(() => yesBtn.focus(), 100)
  }

  showLoading(modalType, message = 'Loading...') {
    const { modal } = this.modals[modalType]
    if (modal) {
      const loadingDiv = document.createElement('div')
      loadingDiv.id = `modalLoading_${modalType}`
      loadingDiv.style.cssText = `
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(255, 255, 255, 0.9);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 9999;
            `
      loadingDiv.innerHTML = `<p style="color: #666;">${message}</p>`
      modal.style.position = 'relative'
      modal.appendChild(loadingDiv)
    }
  }

  hideLoading(modalType = null) {
    if (modalType) {
      const loadingDiv = document.getElementById(`modalLoading_${modalType}`)
      if (loadingDiv) {
        loadingDiv.remove()
      }
    } else {
      Object.keys(this.modals).forEach((type) => {
        const loadingDiv = document.getElementById(`modalLoading_${type}`)
        if (loadingDiv) {
          loadingDiv.remove()
        }
      })
    }
  }

  animateIn(modalType) {
    const { modal } = this.modals[modalType]
    if (modal) {
      modal.style.transform = 'translate(-50%, -60%) scale(0.9)'
      modal.style.opacity = '0'

      requestAnimationFrame(() => {
        modal.style.transition = `all ${CONFIG.UI.MODAL_ANIMATION_DURATION}ms ease-out`
        modal.style.transform = 'translate(-50%, -50%) scale(1)'
        modal.style.opacity = '1'
      })
    }
  }

  showEditFood() {
    this.showModal('editFood')
    setTimeout(() => {
      const nameInput = document.getElementById('editFoodName')
      if (nameInput) nameInput.focus()
    }, 100)
  }

  hideEditFood() {
    this.hideModal('editFood')
  }

  destroy() {
    Object.values(this.modals).forEach(({ overlay }) => {
      if (overlay && overlay.parentNode) {
        overlay.parentNode.removeChild(overlay)
      }
    })
    document.body.style.overflow = 'auto'
    this.activeModal = null
  }
}


models.js:
export class Food {
  constructor(id, name, imageUrl, selected, tags, notes = '', nutrition = null, specificData = '') {
    this.id = id
    this.name = name
    this.imageUrl = imageUrl
    this.selected = selected
    this.tags = tags
    this.notes = notes
    this.nutrition = nutrition || {
      protein: null,
      fat: null,
      carbs: null,
      fiber: null,
      sugar: null,
      sodium: null,
    }
    this.specificData = specificData
  }
}

export class Category {
  constructor(id, name, foods, subgroups) {
    this.id = id
    this.name = name
    this.foods = foods || []
    this.subgroups = subgroups || []
  }
}

export class Subgroup {
  constructor(id, name, foods) {
    this.id = id
    this.name = name
    this.foods = foods || []
  }
}


config.js:
const CONFIG = {
  FILES: {
    DATA_FILE: 'data.json',
    BACKUP_DIR: 'backups',
    IMAGES_DIR: 'images',
    LOGS_DIR: 'logs',
  },

  STORAGE: {
    MAIN_DATA: 'dietHelperData',
    BACKUP_PREFIX: 'dietHelperBackup_',
    SETTINGS: 'dietHelperSettings',
  },

  UI: {
    FOOD_IMAGE_SIZE: {
      GRID: { width: 75, height: 75 },
      MODAL: { width: 200, height: 200 },
    },
    MODAL_ANIMATION_DURATION: 200,
    GRID_COLUMNS: 'auto-fit',
    MIN_CARD_WIDTH: 120,
  },

  VALIDATION: {
    FOOD_NAME: {
      MIN_LENGTH: 1,
      MAX_LENGTH: 100,
      REQUIRED: true,
    },
    TAG_NAME: {
      MIN_LENGTH: 1,
      MAX_LENGTH: 50,
      REQUIRED: true,
    },
    MAX_TAGS_PER_FOOD: 10,
    MAX_TOTAL_TAGS: 100,
    MAX_TOTAL_FOODS: 1000,
  },

  IMAGES: {
    SUPPORTED_FORMATS: ['jpg', 'jpeg', 'png', 'gif', 'webp'],
    MAX_FILE_SIZE: 5 * 1024 * 1024,
    QUALITY: 0.8,
    THUMBNAIL_SIZE: { width: 100, height: 100 },
  },

  DEFAULTS: {
    EMPTY_DATA: {
      foods: [],
      tags: [],
    },
    NEW_FOOD: {
      id: null,
      name: '',
      imageUrl: '',
      selected: false,
      tags: [],
    },
    NEW_TAG: {
      id: null,
      name: '',
    },
  },

  MESSAGES: {
    ERRORS: {
      FOOD_NAME_REQUIRED: 'Please enter food name',
      TAG_NAME_REQUIRED: 'Please enter tag name',
      FOOD_NAME_TOO_LONG: 'Food name is too long (max 100 characters)',
      TAG_NAME_TOO_LONG: 'Tag name is too long (max 50 characters)',
      INVALID_IMAGE_FORMAT: 'Unsupported image format. Please use JPG, PNG, GIF, or WebP',
      IMAGE_TOO_LARGE: 'Image file is too large (max 5MB)',
      SAVE_FAILED: 'Failed to save data. Please try again.',
      LOAD_FAILED: 'Failed to load data',
      MAX_FOODS_REACHED: 'Maximum number of foods reached (1000)',
      MAX_TAGS_REACHED: 'Maximum number of tags reached (100)',
      MAX_TAGS_PER_FOOD: 'Maximum 10 tags per food item',
      DELETE_FOOD_FAILED: 'Failed to delete food. Please try again.',
    },
    SUCCESS: {
      FOOD_SAVED: 'Food saved successfully',
      TAG_SAVED: 'Tag saved successfully',
      DATA_LOADED: 'Data loaded successfully',
      BACKUP_CREATED: 'Backup created successfully',
      FOOD_DELETED: 'Food deleted successfully',
    },
    CONFIRMATIONS: {
      DELETE_TAG: 'Are you sure you want to delete this tag? It will be removed from all foods.',
      DELETE_FOOD: 'Are you sure you want to delete this food item? This action cannot be undone.',
      CLEAR_ALL_DATA: 'Are you sure you want to clear all data? This cannot be undone.',
      RESTORE_BACKUP: 'Are you sure you want to restore from backup? Current data will be lost.',
    },
  },

  FEATURES: {
    ANIMATIONS_ENABLED: true,
    BACKUP_ENABLED: true,
    IMAGE_COMPRESSION: true,
    KEYBOARD_SHORTCUTS: true,
    DARK_MODE: false,
    EXPORT_IMPORT: true,
    STATISTICS: false,
  },

  SHORTCUTS: {
    ADD_FOOD: 'Ctrl+N',
    MANAGE_TAGS: 'Ctrl+T',
    CLOSE_MODAL: 'Escape',
    SAVE: 'Ctrl+S',
    SEARCH: 'Ctrl+F',
    DELETE: 'Delete',
  },

  DEBUG: {
    ENABLED: false,
    LOG_LEVEL: 'info',
    SHOW_PERFORMANCE: false,
  },

  APP: {
    NAME: 'Diet Helper',
    VERSION: '1.0.0',
    AUTHOR: 'Your Name',
    DESCRIPTION: 'A simple diet management application',
  },

  ENV: {
    IS_ELECTRON: typeof require !== 'undefined',
    IS_DEVELOPMENT: false,
  },
}

const ConfigUtils = {
  get(path, defaultValue = null) {
    const keys = path.split('.')
    let current = CONFIG

    for (const key of keys) {
      if (current && typeof current === 'object' && key in current) {
        current = current[key]
      } else {
        return defaultValue
      }
    }

    return current
  },

  set(path, value) {
    const keys = path.split('.')
    const lastKey = keys.pop()
    let current = CONFIG

    for (const key of keys) {
      if (!(key in current)) {
        current[key] = {}
      }
      current = current[key]
    }

    current[lastKey] = value
  },

  validateImage(file) {
    if (!file) return { valid: false, error: 'No file provided' }

    const extension = file.name.split('.').pop().toLowerCase()
    if (!CONFIG.IMAGES.SUPPORTED_FORMATS.includes(extension)) {
      return {
        valid: false,
        error: CONFIG.MESSAGES.ERRORS.INVALID_IMAGE_FORMAT,
      }
    }

    if (file.size > CONFIG.IMAGES.MAX_FILE_SIZE) {
      return {
        valid: false,
        error: CONFIG.MESSAGES.ERRORS.IMAGE_TOO_LARGE,
      }
    }

    return { valid: true }
  },

  validateFoodName(name) {
    if (!name || name.trim().length === 0) {
      return {
        valid: false,
        error: CONFIG.MESSAGES.ERRORS.FOOD_NAME_REQUIRED,
      }
    }

    if (name.length > CONFIG.VALIDATION.FOOD_NAME.MAX_LENGTH) {
      return {
        valid: false,
        error: CONFIG.MESSAGES.ERRORS.FOOD_NAME_TOO_LONG,
      }
    }

    return { valid: true }
  },

  validateTagName(name) {
    if (!name || name.trim().length === 0) {
      return {
        valid: false,
        error: CONFIG.MESSAGES.ERRORS.TAG_NAME_REQUIRED,
      }
    }

    if (name.length > CONFIG.VALIDATION.TAG_NAME.MAX_LENGTH) {
      return {
        valid: false,
        error: CONFIG.MESSAGES.ERRORS.TAG_NAME_TOO_LONG,
      }
    }

    return { valid: true }
  },

  isFeatureEnabled(feature) {
    return CONFIG.FEATURES[feature] === true
  },

  getFilePath(fileKey) {
    return CONFIG.FILES[fileKey] || ''
  },

  getStorageKey(keyName) {
    return CONFIG.STORAGE[keyName] || ''
  },

  log(level, message, data = null) {
    if (!CONFIG.DEBUG.ENABLED) return

    const levels = ['debug', 'info', 'warn', 'error']
    const currentLevelIndex = levels.indexOf(CONFIG.DEBUG.LOG_LEVEL)
    const messageLevelIndex = levels.indexOf(level)

    if (messageLevelIndex >= currentLevelIndex) {
      const timestamp = new Date().toISOString()
      const logMessage = `[${timestamp}] [${level.toUpperCase()}] ${message}`

      console[level === 'debug' ? 'log' : level](logMessage, data || '')
    }
  },
}

ConfigUtils.set('ENV.IS_DEVELOPMENT', window.location.hostname === 'localhost')

export { CONFIG, ConfigUtils }



























okay but from now on when i ask you any improvement implementation or fixing some things dont give me full code files ok? 
just give me needed function to replace or add and where i have to add or replace in which file and in which section like 
after that function before that function in that funcvtion ect right?



























































































































