
okay so here is my current project that named diet helper and helps me to organize my diet:
it consists of index html style css and those js files:
models,app,config,modal,ui,data

i will give you every files:

first of all just get familiar with my code
index html:
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Diet Helper</title>
    <link rel="stylesheet" href="style.css" />
  </head>
  <body>
    <h1>Diet Helper</h1>

    <button id="addCategoryBtn">Add Category</button>
    <button id="manageTagsBtn">Manage Tags</button>
    <button id="editModeBtn">Edit</button>

    <div id="categoriesContainer"></div>

    <!-- Food Details Dropdown -->
    <div id="foodDetailsDropdown" class="dropdown">
      <h3>Food Details</h3>
      <div id="foodDetailsContent">
        <div style="text-align: center">
          <img
            id="detailsImage"
            style="width: 200px; height: 200px; object-fit: cover; margin-bottom: 15px"
            src=""
            alt=""
          />
          <h3 id="detailsName" style="margin: 10px 0"></h3>
          <div id="detailsTags" style="color: #666; margin-bottom: 15px"></div>
        </div>
      </div>
      <div class="modal-buttons">
        <button id="deleteFoodBtn" class="btn-danger">Delete</button>
        <button id="closeFoodDetailsBtn" class="btn-secondary">Close</button>
      </div>
    </div>

    <!-- Add Food Dropdown -->
    <div id="addFoodDropdown" class="dropdown">
      <h3>Add New Food</h3>
      <div class="form-group">
        <input type="text" id="foodName" placeholder="Enter food name" />
        <div id="foodNameError" class="error-message hidden">Please enter food name</div>
      </div>
      <div class="form-group">
        <label>Food Image:</label>
        <input type="file" id="foodImage" accept="image/*" />
      </div>
      <div class="form-group">
        <label>Select Tags:</label>
        <div id="tagsList"></div>
      </div>
      <div class="modal-buttons">
        <button id="saveFoodBtn" class="btn-primary">Save Food</button>
        <button id="cancelFoodBtn" class="btn-secondary">Cancel</button>
      </div>
    </div>

    <!-- Manage Tags Dropdown -->
    <div id="manageTagsDropdown" class="dropdown">
      <h3>Manage Tags</h3>
      <div class="form-group">
        <input type="text" id="newTagName" placeholder="Enter tag name" />
        <div id="tagNameError" class="error-message hidden">Please enter tag name</div>
        <button id="addTagBtn" class="btn-primary">Add Tag</button>
      </div>
      <div id="existingTags"></div>
      <div class="modal-buttons">
        <button id="closeTagsBtn" class="btn-secondary">Close</button>
      </div>
    </div>

    <!-- Add Category Modal -->
    <div id="addCategoryDropdown" class="dropdown">
      <h3>Add New Category</h3>
      <div class="form-group">
        <input type="text" id="categoryNameInput" placeholder="Enter category name" />
        <div id="categoryNameError" class="error-message hidden">Please enter category name</div>
      </div>
      <div class="modal-buttons">
        <button id="saveCategoryBtn" class="btn-primary">Save Category</button>
        <button id="cancelCategoryBtn" class="btn-secondary">Cancel</button>
      </div>
    </div>

    <!-- Confirmation Modal -->
    <div id="confirmationDropdown" class="dropdown">
      <h3 id="confirmTitle">Confirm Delete</h3>
      <p id="confirmMessage" style="margin: 20px 0; color: #333"></p>
      <div class="modal-buttons">
        <button id="confirmYesBtn" class="btn-danger">Delete</button>
        <button id="confirmNoBtn" class="btn-secondary">Cancel</button>
      </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
    <script type="module" src="app.js"></script>
  </body>
</html>

style css:
body {
  font-family: Arial, sans-serif;
  margin: 20px;
}
button {
  padding: 10px 15px;
  margin: 5px;
  cursor: pointer;
}
.dropdown {
  display: none;
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: white;
  border: 2px solid #ccc;
  padding: 20px;
  z-index: 1000;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
  border-radius: 8px;
  min-width: 300px;
}
.dropdown.active {
  display: block;
}
.modal-overlay {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.5);
  z-index: 999;
}
.modal-overlay.active {
  display: block;
}
.form-group {
  margin: 10px 0;
}
.form-group label {
  display: block;
  margin-bottom: 5px;
}
.form-group input,
.form-group select {
  width: 200px;
  padding: 5px;
}
.tag-item {
  margin: 5px 0;
  padding: 5px;
  border: 1px solid #ddd;
}
.tag-checkbox {
  margin-right: 10px;
}
.food-item {
  border: 1px solid #ccc;
  margin: 5px;
  padding: 5px;
  display: inline-block;
  width: 85px;
  text-align: center;
  vertical-align: top;
}
.food-image {
  width: 75px;
  height: 75px;
  object-fit: cover;
  display: block;
  margin: 0 auto 5px auto;
  cursor: pointer;
  box-sizing: border-box;
}

.food-image.no-image {
  background: #f0f0f0;
  line-height: 75px;
  text-align: center;
  font-size: 11px;
  color: #999;
}
.food-image:hover {
  opacity: 0.8;
  border: 2px solid #007bff;
}
.food-name {
  font-size: 12px;
  font-weight: bold;
  margin: 3px 0;
}
.food-tags {
  font-size: 12px;
  color: #666;
}
.error-message {
  color: red;
  font-size: 12px;
  margin-top: 5px;
}
.hidden {
  display: none;
}

/* Button styles for modal actions */
.modal-buttons {
  display: flex;
  gap: 10px;
  justify-content: flex-end;
  margin-top: 20px;
  padding-top: 15px;
  border-top: 1px solid #eee;
}

.btn-primary {
  background-color: #007bff;
  color: white;
  border: none;
  border-radius: 4px;
}

.btn-primary:hover {
  background-color: #0056b3;
}

.btn-danger {
  background-color: #dc3545;
  color: white;
  border: none;
  border-radius: 4px;
}

.btn-danger:hover {
  background-color: #c82333;
}

.btn-secondary {
  background-color: #6c757d;
  color: white;
  border: none;
  border-radius: 4px;
}

.btn-secondary:hover {
  background-color: #545b62;
}
#modalOverlay {
  display: none !important;
  visibility: hidden !important;
}

input[type='text'] {
  border: 1px solid #007bff;
  border-radius: 3px;
  outline: none;
}

/* Edit mode styles */
.edit-mode .category-container {
  border: 2px solid #007bff !important;
}

/* Sortable styles */
.edit-mode .category-header {
  cursor: move;
  background: #f5f5f5;
  margin: -10px -10px 10px -10px;
  padding: 10px;
}

.edit-mode .food-item {
  cursor: move;
  transition: transform 0.2s;
}

.edit-mode .food-item:hover {
  transform: scale(1.05);
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
}

.sortable-ghost {
  opacity: 0.4;
}

.sortable-drag {
  opacity: 0.8;
  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
}
/* Ensure proper scrolling */
body {
  min-height: 100vh;
  overflow-y: auto;
}

#categoriesContainer {
  padding-bottom: 50px; /* Extra space at bottom for easier dropping */
}
/* Ensure confirmation modal appears on top */
#confirmationOverlay {
  z-index: 1010;
}

#confirmationDropdown {
  z-index: 1011;
}

app js:
import { CONFIG } from './config.js'
import { Food, Category } from './models.js'
import { DataManager } from './data.js'
import { UIManager } from './ui.js'
import { ModalManager } from './modal.js'

// Debug: Monitor what's setting tabIndex on body
const originalSetAttribute = document.body.setAttribute
document.body.setAttribute = function (name, value) {
  if (name === 'tabindex' || name === 'tabIndex') {
  }
  return originalSetAttribute.call(this, name, value)
}

// Also monitor the property directly
Object.defineProperty(document.body, 'tabIndex', {
  set: function (value) {
    this.setAttribute('tabindex', value)
  },
  get: function () {
    return parseInt(this.getAttribute('tabindex') || '0')
  },
})

class DietHelper {
  constructor() {
    this.foods = []
    this.tags = []
    this.categories = []
    this.currentCategoryId = null
    this.isEditMode = false
    this.categorySortable = null
    this.foodSortables = {}
    this.currentFoodId = null // Track currently viewed food for deletion
    this.dataManager = new DataManager()
    this.uiManager = new UIManager()
    this.modalManager = new ModalManager()
    this.init()
  }

  async init() {
    const result = await this.dataManager.loadData()
    if (result.success) {
      this.foods = result.data.foods
      this.tags = result.data.tags
      this.categories = result.data.categories || []
      this.uiManager.renderCategories(this.categories, this.isEditMode)
    }
    this.initializeEventListeners()
  }

  initializeEventListeners() {
    // Manage Tags Button
    document.getElementById('manageTagsBtn').addEventListener('click', () => {
      this.showManageTagsForm()
    })

    // Edit Mode Button
    document.getElementById('editModeBtn').addEventListener('click', () => {
      this.toggleEditMode()
    })

    // Add Category Button
    document.getElementById('addCategoryBtn').addEventListener('click', () => {
      this.showAddCategoryForm()
    })

    // Save Category Button
    document.getElementById('saveCategoryBtn').addEventListener('click', () => {
      this.saveCategory()
    })

    // Cancel Category Button
    document.getElementById('cancelCategoryBtn').addEventListener('click', () => {
      this.hideAddCategoryForm()
    })

    // Save Food Button
    document.getElementById('saveFoodBtn').addEventListener('click', () => {
      this.saveFood()
    })

    // Cancel Food Button
    document.getElementById('cancelFoodBtn').addEventListener('click', () => {
      this.hideAddFoodForm()
    })

    // Add Tag Button
    document.getElementById('addTagBtn').addEventListener('click', () => {
      this.addTag()
    })

    // Close Food Details Button
    document.getElementById('closeFoodDetailsBtn').addEventListener('click', () => {
      this.hideFoodDetails()
    })

    // Delete Food Button - NEW
    document.getElementById('deleteFoodBtn').addEventListener('click', () => {
      this.deleteFood()
    })

    // Close Tags Button
    document.getElementById('closeTagsBtn').addEventListener('click', () => {
      this.hideManageTagsForm()
    })
  }

  showAddFoodForm(categoryId = null) {
    this.modalManager.closeActiveModal()

    this.currentCategoryId = categoryId
    this.uiManager.renderTagsForSelection(this.tags)
    this.modalManager.showAddFood()
  }

  hideAddFoodForm() {
    this.modalManager.hideAddFood()
    this.uiManager.clearFoodForm()
  }

  showManageTagsForm() {
    this.uiManager.renderExistingTags(this.tags)
    this.modalManager.showManageTags()
  }

  hideManageTagsForm() {
    this.modalManager.hideManageTags()
  }

  showFoodDetails(foodId) {
    const food = this.foods.find((f) => f.id === foodId)
    if (!food) return

    // Store the current food ID for deletion
    this.currentFoodId = foodId

    this.uiManager.showFoodDetails(food, this.tags)
    this.modalManager.showFoodDetails()
  }

  hideFoodDetails() {
    this.currentFoodId = null
    this.currentCategoryId = null

    // Force complete modal cleanup
    this.modalManager.hideFoodDetails()

    // Reset all focus-related states
    setTimeout(() => {
      // Remove any lingering focus from body
      if (document.activeElement === document.body) {
        document.activeElement.blur()
      }

      // Ensure body is not focusable
      document.body.removeAttribute('tabIndex')
      document.body.style.overflow = 'auto'

      // Force browser to recalculate
      document.body.offsetHeight
    }, 50)
  }

  // NEW: Delete food functionality
  async deleteFood() {
    if (!this.currentFoodId) return

    let foodName = 'this food'

    if (this.currentCategoryId) {
      const category = this.categories.find((c) => c.id === this.currentCategoryId)
      const food = category?.foods.find((f) => f.id === this.currentFoodId)
      foodName = food?.name || 'this food'
    } else {
      const food = this.foods.find((f) => f.id === this.currentFoodId)
      foodName = food?.name || 'this food'
    }

    this.modalManager.showConfirmation(`Are you sure you want to delete "${foodName}"?`, () => {
      this.performDeleteFood(this.currentFoodId)
    })
  }

  // NEW: Perform the actual food deletion
  async performDeleteFood(foodId) {
    try {
      let food = null

      if (this.currentCategoryId) {
        const category = this.categories.find((c) => c.id === this.currentCategoryId)
        if (category) {
          food = category.foods.find((f) => f.id === foodId)
          category.foods = category.foods.filter((f) => f.id !== foodId)
        }
      } else {
        food = this.foods.find((f) => f.id === foodId)
        this.foods = this.foods.filter((f) => f.id !== foodId)
      }

      // Delete the image file if it exists and is not base64
      if (food && food.imageUrl && !food.imageUrl.startsWith('data:')) {
        const deleteResult = await this.dataManager.deleteImage(food.imageUrl)
      }

      await this.saveAllData()
      this.uiManager.renderCategories(this.categories, this.isEditMode)

      this.hideFoodDetails()

      // Electron-specific: Force webContents to refocus after deletion
      if (typeof require !== 'undefined') {
        // We're in Electron
        setTimeout(() => {
          // Force the webContents to blur and refocus
          const currentWindow = window
          currentWindow.blur()
          setTimeout(() => {
            currentWindow.focus()
          }, 50)
        }, 100)
      }
    } catch (error) {
      alert('Failed to delete food. Please try again.')
    }
  }
  async saveFood() {
    const formData = this.uiManager.getFoodFormData()

    if (!formData.name) {
      this.uiManager.showError('foodNameError', CONFIG.MESSAGES.ERRORS.FOOD_NAME_REQUIRED)
      this.uiManager.focusElement('foodName')
      return
    }

    this.uiManager.hideError('foodNameError')

    // FIXED: Disable save button instead of overlay
    const saveBtn = document.getElementById('saveFoodBtn')
    const originalText = saveBtn.textContent
    saveBtn.disabled = true
    saveBtn.textContent = 'Saving...'

    // Handle image
    let imageUrl = ''
    if (formData.image) {
      const imageResult = await this.dataManager.saveImage(formData.image)

      if (imageResult.success) {
        imageUrl = imageResult.path
      }
    }

    // Re-enable button
    saveBtn.disabled = false
    saveBtn.textContent = originalText

    this.createAndSaveFood(formData.name, imageUrl, formData.tags)
  }

  async createAndSaveFood(name, imageUrl, selectedTags) {
    const newFood = new Food(Date.now(), name, imageUrl, false, selectedTags)

    // Validate food data
    const validation = this.dataManager.validateFood(newFood)
    if (!validation.isValid) {
      alert('Invalid food data: ' + validation.errors.join(', '))
      return
    }

    if (this.currentCategoryId) {
      const category = this.categories.find((c) => c.id === this.currentCategoryId)
      if (category) {
        category.foods.push(newFood)
      }
    } else {
      this.foods.push(newFood)
    }

    await this.saveAllData()
    this.uiManager.renderCategories(this.categories, this.isEditMode)
    this.hideAddFoodForm()
  }

  async addTag() {
    const formData = this.uiManager.getTagFormData()

    if (!formData.name) {
      this.uiManager.showError('tagNameError', CONFIG.MESSAGES.ERRORS.TAG_NAME_REQUIRED)
      this.uiManager.focusElement('newTagName')
      return
    }

    this.uiManager.hideError('tagNameError')

    const newTag = {
      id: Date.now(),
      name: formData.name,
    }

    // Validate tag data
    const validation = this.dataManager.validateTag(newTag)
    if (!validation.isValid) {
      alert('Invalid tag data: ' + validation.errors.join(', '))
      return
    }

    this.tags.push(newTag)
    this.uiManager.clearTagForm()
    await this.saveAllData()
    this.uiManager.renderExistingTags(this.tags)
  }

  async deleteTag(tagId) {
    const confirmed = this.modalManager.showConfirmation(
      CONFIG.MESSAGES.CONFIRMATIONS.DELETE_TAG,
      () => {
        this.performDeleteTag(tagId)
      }
    )
  }

  async performDeleteTag(tagId) {
    this.tags = this.tags.filter((tag) => tag.id !== tagId)
    // Remove tag from all foods
    this.foods.forEach((food) => {
      food.tags = food.tags.filter((id) => id !== tagId)
    })
    await this.saveAllData()
    this.uiManager.renderExistingTags(this.tags)
    // Re-render foods in case any displayed foods had this tag
    this.uiManager.renderFoods(this.foods, this.tags)
  }

  showAddCategoryForm() {
    document.getElementById('categoryNameInput').value = ''
    this.uiManager.hideError('categoryNameError')
    this.modalManager.showAddCategory()
  }

  hideAddCategoryForm() {
    this.modalManager.hideAddCategory()
  }

  saveCategory() {
    const categoryName = document.getElementById('categoryNameInput').value.trim()

    if (!categoryName) {
      this.uiManager.showError('categoryNameError', 'Please enter category name')
      return
    }

    const newCategory = new Category(Date.now(), categoryName, [])

    this.categories.push(newCategory)
    this.saveAllData()
    this.uiManager.renderCategories(this.categories, this.isEditMode)
    this.hideAddCategoryForm()
  }

  toggleEditMode() {
    this.isEditMode = !this.isEditMode

    // Update button text
    const editBtn = document.getElementById('editModeBtn')
    editBtn.textContent = this.isEditMode ? 'Done' : 'Edit'
    editBtn.style.backgroundColor = this.isEditMode ? '#28a745' : ''

    // First, re-render with edit mode state
    this.uiManager.renderCategories(this.categories, this.isEditMode)

    // Then, update container classes and sorting
    const container = document.getElementById('categoriesContainer')
    if (this.isEditMode) {
      container.classList.add('edit-mode')
      // Enable sorting AFTER rendering
      setTimeout(() => {
        this.enableCategorySorting()
      }, 150) // Slightly longer delay
    } else {
      container.classList.remove('edit-mode')
      this.disableCategorySorting()
    }
  }

  enableCategorySorting() {
    const container = document.getElementById('categoriesContainer')

    // Enable category sorting with better scroll config
    this.categorySortable = Sortable.create(container, {
      animation: 150,
      handle: '.category-header',
      draggable: '.category-container',
      scroll: true,
      forceAutoScrollFallback: true, // Force the auto-scroll
      scrollSensitivity: 100, // Increased sensitivity
      scrollSpeed: 20, // Faster scrolling
      onEnd: (evt) => {
        const movedCategory = this.categories.splice(evt.oldIndex, 1)[0]
        this.categories.splice(evt.newIndex, 0, movedCategory)
        this.saveAllData()
      },
    })

    // Enable food sorting within each category
    this.enableFoodSorting()
  }

  disableCategorySorting() {
    // Disable category sorting
    if (this.categorySortable) {
      this.categorySortable.destroy()
      this.categorySortable = null
    }

    // Disable food sorting
    this.disableFoodSorting()
  }

  enableFoodSorting() {
    this.categories.forEach((category) => {
      const foodsContainer = document.getElementById(`foods-${category.id}`)
      if (foodsContainer) {
        this.foodSortables[category.id] = Sortable.create(foodsContainer, {
          group: `foods-${category.id}`,
          animation: 150,
          draggable: '.food-item',
          scroll: true, // Enable auto-scrolling
          scrollSensitivity: 30,
          scrollSpeed: 10,
          onEnd: (evt) => {
            const movedFood = category.foods.splice(evt.oldIndex, 1)[0]
            category.foods.splice(evt.newIndex, 0, movedFood)
            this.saveAllData()
          },
        })
      }
    })
  }

  disableFoodSorting() {
    Object.values(this.foodSortables).forEach((sortable) => {
      if (sortable) {
        sortable.destroy()
      }
    })
    this.foodSortables = {}
  }

  startRenameCategory(categoryId) {
    const category = this.categories.find((c) => c.id === categoryId)
    if (!category) return

    const nameSpan = document.getElementById(`categoryName-${categoryId}`)
    if (!nameSpan) return

    // Store original name in case of cancel
    const originalName = category.name

    // Create input element
    const input = document.createElement('input')
    input.type = 'text'
    input.value = category.name
    input.style.cssText = 'font-weight: bold; padding: 2px 5px; margin-right: 10px;'

    // Replace span with input
    nameSpan.parentNode.replaceChild(input, nameSpan)
    input.focus()
    input.select()

    // Handle save on Enter or blur
    const saveRename = () => {
      const newName = input.value.trim()
      if (newName && newName !== originalName) {
        category.name = newName
        this.saveAllData()
      }
      this.uiManager.renderCategories(this.categories, this.isEditMode)
    }

    // Handle cancel on Escape
    const cancelRename = (e) => {
      if (e.key === 'Escape') {
        this.uiManager.renderCategories(this.categories, this.isEditMode)
      }
    }

    input.addEventListener('blur', saveRename)
    input.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault()
        saveRename()
      } else if (e.key === 'Escape') {
        cancelRename(e)
      }
    })
  }

  renameCategory(categoryId) {
    // This is now just an alias for startRenameCategory
    this.startRenameCategory(categoryId)
  }

  deleteCategory(categoryId) {
    const category = this.categories.find((c) => c.id === categoryId)
    if (!category) return

    const foodCount = category.foods.length
    const message =
      foodCount > 0
        ? `Delete "${category.name}" and its ${foodCount} food${foodCount > 1 ? 's' : ''}?`
        : `Delete empty category "${category.name}"?`

    this.modalManager.showConfirmation(message, () => {
      this.categories = this.categories.filter((c) => c.id !== categoryId)
      this.saveAllData()
      this.uiManager.renderCategories(this.categories, this.isEditMode)
    })
  }

  showCategoryFoodDetails(categoryId, foodId) {
    const category = this.categories.find((c) => c.id === categoryId)
    if (!category) return

    const food = category.foods.find((f) => f.id === foodId)
    if (!food) return

    this.currentFoodId = foodId
    this.currentCategoryId = categoryId

    this.uiManager.showFoodDetails(food, this.tags)
    this.modalManager.showFoodDetails()
  }

  async saveAllData() {
    const data = {
      foods: this.foods,
      tags: this.tags,
      categories: this.categories,
    }

    const result = await this.dataManager.saveData(data)
    if (!result.success) {
      console.error('Failed to save data:', result.error)
      alert(CONFIG.MESSAGES.ERRORS.SAVE_FAILED)
    }
  }
}

// Initialize the app
const dietHelper = new DietHelper()

// Make available for HTML onclick handlers (only this instance)
window.dietHelper = dietHelper

models js:
export class Food {
  constructor(id, name, imageUrl, selected, tags) {
    this.id = id
    this.name = name
    this.imageUrl = imageUrl
    this.selected = selected
    this.tags = tags
  }
}

export class Category {
  constructor(id, name, foods) {
    this.id = id
    this.name = name
    this.foods = foods || []
  }
}

config js:
const CONFIG = {
  // File paths and directories
  FILES: {
    DATA_FILE: 'data.json',
    BACKUP_DIR: 'backups',
    IMAGES_DIR: 'images',
    LOGS_DIR: 'logs',
  },

  // Storage keys for browser fallback
  STORAGE: {
    MAIN_DATA: 'dietHelperData',
    BACKUP_PREFIX: 'dietHelperBackup_',
    SETTINGS: 'dietHelperSettings',
  },

  // UI Configuration
  UI: {
    FOOD_IMAGE_SIZE: {
      GRID: { width: 75, height: 75 },
      MODAL: { width: 200, height: 200 },
    },
    MODAL_ANIMATION_DURATION: 200,
    GRID_COLUMNS: 'auto-fit',
    MIN_CARD_WIDTH: 120,
  },

  // Validation rules
  VALIDATION: {
    FOOD_NAME: {
      MIN_LENGTH: 1,
      MAX_LENGTH: 100,
      REQUIRED: true,
    },
    TAG_NAME: {
      MIN_LENGTH: 1,
      MAX_LENGTH: 50,
      REQUIRED: true,
    },
    MAX_TAGS_PER_FOOD: 10,
    MAX_TOTAL_TAGS: 100,
    MAX_TOTAL_FOODS: 1000,
  },

  // Image handling
  IMAGES: {
    SUPPORTED_FORMATS: ['jpg', 'jpeg', 'png', 'gif', 'webp'],
    MAX_FILE_SIZE: 5 * 1024 * 1024, // 5MB
    QUALITY: 0.8,
    THUMBNAIL_SIZE: { width: 100, height: 100 },
  },

  // Default data structure
  DEFAULTS: {
    EMPTY_DATA: {
      foods: [],
      tags: [],
    },
    NEW_FOOD: {
      id: null,
      name: '',
      imageUrl: '',
      selected: false,
      tags: [],
    },
    NEW_TAG: {
      id: null,
      name: '',
    },
  },

  // Error messages
  MESSAGES: {
    ERRORS: {
      FOOD_NAME_REQUIRED: 'Please enter food name',
      TAG_NAME_REQUIRED: 'Please enter tag name',
      FOOD_NAME_TOO_LONG: 'Food name is too long (max 100 characters)',
      TAG_NAME_TOO_LONG: 'Tag name is too long (max 50 characters)',
      INVALID_IMAGE_FORMAT: 'Unsupported image format. Please use JPG, PNG, GIF, or WebP',
      IMAGE_TOO_LARGE: 'Image file is too large (max 5MB)',
      SAVE_FAILED: 'Failed to save data. Please try again.',
      LOAD_FAILED: 'Failed to load data',
      MAX_FOODS_REACHED: 'Maximum number of foods reached (1000)',
      MAX_TAGS_REACHED: 'Maximum number of tags reached (100)',
      MAX_TAGS_PER_FOOD: 'Maximum 10 tags per food item',
      DELETE_FOOD_FAILED: 'Failed to delete food. Please try again.',
    },
    SUCCESS: {
      FOOD_SAVED: 'Food saved successfully',
      TAG_SAVED: 'Tag saved successfully',
      DATA_LOADED: 'Data loaded successfully',
      BACKUP_CREATED: 'Backup created successfully',
      FOOD_DELETED: 'Food deleted successfully',
    },
    CONFIRMATIONS: {
      DELETE_TAG: 'Are you sure you want to delete this tag? It will be removed from all foods.',
      DELETE_FOOD: 'Are you sure you want to delete this food item? This action cannot be undone.',
      CLEAR_ALL_DATA: 'Are you sure you want to clear all data? This cannot be undone.',
      RESTORE_BACKUP: 'Are you sure you want to restore from backup? Current data will be lost.',
    },
  },

  // Feature flags
  FEATURES: {
    ANIMATIONS_ENABLED: true,
    BACKUP_ENABLED: true,
    IMAGE_COMPRESSION: true,
    KEYBOARD_SHORTCUTS: true,
    DARK_MODE: false,
    EXPORT_IMPORT: true,
    STATISTICS: false,
  },

  // Keyboard shortcuts
  SHORTCUTS: {
    ADD_FOOD: 'Ctrl+N',
    MANAGE_TAGS: 'Ctrl+T',
    CLOSE_MODAL: 'Escape',
    SAVE: 'Ctrl+S',
    SEARCH: 'Ctrl+F',
    DELETE: 'Delete',
  },

  // Development settings
  DEBUG: {
    ENABLED: false,
    LOG_LEVEL: 'info', // 'debug', 'info', 'warn', 'error'
    SHOW_PERFORMANCE: false,
  },

  // App metadata
  APP: {
    NAME: 'Diet Helper',
    VERSION: '1.0.0',
    AUTHOR: 'Your Name',
    DESCRIPTION: 'A simple diet management application',
  },

  // Environment detection
  ENV: {
    IS_ELECTRON: typeof require !== 'undefined',
    IS_DEVELOPMENT: false, // Will be set based on environment
  },
}

// Utility functions for config
const ConfigUtils = {
  // Get nested config value safely
  get(path, defaultValue = null) {
    const keys = path.split('.')
    let current = CONFIG

    for (const key of keys) {
      if (current && typeof current === 'object' && key in current) {
        current = current[key]
      } else {
        return defaultValue
      }
    }

    return current
  },

  // Set nested config value
  set(path, value) {
    const keys = path.split('.')
    const lastKey = keys.pop()
    let current = CONFIG

    for (const key of keys) {
      if (!(key in current)) {
        current[key] = {}
      }
      current = current[key]
    }

    current[lastKey] = value
  },

  // Validate image file
  validateImage(file) {
    if (!file) return { valid: false, error: 'No file provided' }

    const extension = file.name.split('.').pop().toLowerCase()
    if (!CONFIG.IMAGES.SUPPORTED_FORMATS.includes(extension)) {
      return {
        valid: false,
        error: CONFIG.MESSAGES.ERRORS.INVALID_IMAGE_FORMAT,
      }
    }

    if (file.size > CONFIG.IMAGES.MAX_FILE_SIZE) {
      return {
        valid: false,
        error: CONFIG.MESSAGES.ERRORS.IMAGE_TOO_LARGE,
      }
    }

    return { valid: true }
  },

  // Validate food name
  validateFoodName(name) {
    if (!name || name.trim().length === 0) {
      return {
        valid: false,
        error: CONFIG.MESSAGES.ERRORS.FOOD_NAME_REQUIRED,
      }
    }

    if (name.length > CONFIG.VALIDATION.FOOD_NAME.MAX_LENGTH) {
      return {
        valid: false,
        error: CONFIG.MESSAGES.ERRORS.FOOD_NAME_TOO_LONG,
      }
    }

    return { valid: true }
  },

  // Validate tag name
  validateTagName(name) {
    if (!name || name.trim().length === 0) {
      return {
        valid: false,
        error: CONFIG.MESSAGES.ERRORS.TAG_NAME_REQUIRED,
      }
    }

    if (name.length > CONFIG.VALIDATION.TAG_NAME.MAX_LENGTH) {
      return {
        valid: false,
        error: CONFIG.MESSAGES.ERRORS.TAG_NAME_TOO_LONG,
      }
    }

    return { valid: true }
  },

  // Check if feature is enabled
  isFeatureEnabled(feature) {
    return CONFIG.FEATURES[feature] === true
  },

  // Get file path
  getFilePath(fileKey) {
    return CONFIG.FILES[fileKey] || ''
  },

  // Get storage key
  getStorageKey(keyName) {
    return CONFIG.STORAGE[keyName] || ''
  },

  // Debug logging
  log(level, message, data = null) {
    if (!CONFIG.DEBUG.ENABLED) return

    const levels = ['debug', 'info', 'warn', 'error']
    const currentLevelIndex = levels.indexOf(CONFIG.DEBUG.LOG_LEVEL)
    const messageLevelIndex = levels.indexOf(level)

    if (messageLevelIndex >= currentLevelIndex) {
      const timestamp = new Date().toISOString()
      const logMessage = `[${timestamp}] [${level.toUpperCase()}] ${message}`

      console[level === 'debug' ? 'log' : level](logMessage, data || '')
    }
  },
}

// Set environment
ConfigUtils.set('ENV.IS_DEVELOPMENT', window.location.hostname === 'localhost')

// Export using ES6 modules
export { CONFIG, ConfigUtils }


 modal js:

import { CONFIG } from './config.js'

export class ModalManager {
  constructor() {
    // FIXED: Create individual overlays for each modal type for better isolation
    this.modals = {
      foodDetails: {
        modal: document.getElementById('foodDetailsDropdown'),
        overlay: this.createOverlay('foodDetailsOverlay'),
      },
      addFood: {
        modal: document.getElementById('addFoodDropdown'),
        overlay: this.createOverlay('addFoodOverlay'),
      },
      manageTags: {
        modal: document.getElementById('manageTagsDropdown'),
        overlay: this.createOverlay('manageTagsOverlay'),
      },
      addCategory: {
        modal: document.getElementById('addCategoryDropdown'),
        overlay: this.createOverlay('addCategoryOverlay'),
      },
      confirmation: {
        modal: document.getElementById('confirmationDropdown'),
        overlay: this.createOverlay('confirmationOverlay'),
      },
    }

    this.activeModal = null
    this.initializeEventListeners()
    this.replaceSharedOverlay()
  }

  // FIXED: Create individual overlay for each modal
  createOverlay(id) {
    const overlay = document.createElement('div')
    overlay.id = id
    overlay.className = 'modal-overlay'
    overlay.style.cssText = `
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 999;
        `
    document.body.appendChild(overlay)
    return overlay
  }

  // FIXED: Replace the shared overlay system
  // FIXED: Replace the shared overlay system
  // FIXED: Replace the shared overlay system
  replaceSharedOverlay() {
    // Don't remove the overlay, just disable its functionality
    const oldOverlay = document.getElementById('modalOverlay')
    if (oldOverlay) {
      oldOverlay.style.display = 'none !important'
      oldOverlay.style.visibility = 'hidden'
      // Remove any existing event listeners
      oldOverlay.replaceWith(oldOverlay.cloneNode(true))
    }
  }

  initializeEventListeners() {
    // FIXED: Add individual click handlers for each overlay
    Object.keys(this.modals).forEach((modalType) => {
      const { overlay } = this.modals[modalType]
      if (overlay) {
        overlay.addEventListener('click', () => {
          this.closeModal(modalType)
        })
      }
    })

    // Close modal on Escape key
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        this.closeActiveModal()
      }
    })

    // Prevent modal content clicks from closing modal
    Object.values(this.modals).forEach(({ modal }) => {
      if (modal) {
        modal.addEventListener('click', (e) => {
          e.stopPropagation()
        })
      }
    })
  }

  // FIXED: Generic method to show any modal
  showModal(modalType) {
    console.log(`[MODAL] showModal called for: ${modalType}`)
    console.log(`[MODAL] Body tabIndex before: ${document.body.tabIndex}`)
    console.log(
      `[MODAL] Active element before: ${document.activeElement?.tagName} (${document.activeElement?.id})`
    )

    this.closeActiveModal() // Close any open modal first

    const { modal, overlay } = this.modals[modalType]
    if (!modal || !overlay) return

    this.activeModal = modalType

    // Reset modal dimensions to prevent size issues
    modal.style.width = ''
    modal.style.height = ''
    modal.style.maxWidth = '90vw'
    modal.style.maxHeight = '90vh'

    overlay.style.display = 'block'
    overlay.classList.add('active')
    modal.classList.add('active')

    // Prevent body scrolling when modal is open
    document.body.style.overflow = 'hidden'

    // Add animation if enabled
    if (CONFIG.FEATURES.ANIMATIONS_ENABLED) {
      this.animateIn(modalType)
    }
  }
  // Show modal without closing others (for stacking)
  showModalStacked(modalType) {
    const { modal, overlay } = this.modals[modalType]
    if (!modal || !overlay) return

    // Store previous active modal to restore later
    this._previousModal = this.activeModal
    this.activeModal = modalType

    // Reset modal dimensions
    modal.style.width = ''
    modal.style.height = ''
    modal.style.maxWidth = '90vw'
    modal.style.maxHeight = '90vh'

    overlay.style.display = 'block'
    overlay.classList.add('active')
    modal.classList.add('active')

    // Keep body overflow hidden
    document.body.style.overflow = 'hidden'

    // Add animation if enabled
    if (CONFIG.FEATURES.ANIMATIONS_ENABLED) {
      this.animateIn(modalType)
    }
  }

  // FIXED: Generic method to hide any modal
  hideModal(modalType) {
    const { modal, overlay } = this.modals[modalType]
    if (!modal || !overlay) return

    const doHide = () => {
      overlay.style.display = 'none'
      overlay.classList.remove('active')
      modal.classList.remove('active')

      if (this.activeModal === modalType) {
        this.activeModal = null
      }

      // ALWAYS reset body state when ANY modal closes
      document.body.style.overflow = 'auto'
      document.body.removeAttribute('tabIndex')

      console.log('[MODAL] Body tabIndex after hide:', document.body.tabIndex)
    }

    if (CONFIG.FEATURES.ANIMATIONS_ENABLED) {
      this.animateOut(modalType, doHide)
    } else {
      doHide()
    }
  }
  // Hide stacked modal and restore previous
  hideModalStacked(modalType) {
    const { modal, overlay } = this.modals[modalType]
    if (!modal || !overlay) return

    const doHide = () => {
      overlay.style.display = 'none'
      overlay.classList.remove('active')
      modal.classList.remove('active')

      // Restore previous active modal
      this.activeModal = this._previousModal || null
      this._previousModal = null

      // Only reset body if no other modals are active
      if (!this.activeModal) {
        document.body.style.overflow = 'auto'
        document.body.removeAttribute('tabIndex')
      }
    }

    if (CONFIG.FEATURES.ANIMATIONS_ENABLED) {
      this.animateOut(modalType, doHide)
    } else {
      doHide()
    }
  }

  // FIXED: Close specific modal
  closeModal(modalType) {
    this.hideModal(modalType)
  }

  // Show food details modal
  showFoodDetails() {
    this.showModal('foodDetails')
  }

  // Hide food details modal
  hideFoodDetails() {
    this.hideModal('foodDetails')
  }

  // Show add food modal
  showAddFood() {
    this.showModal('addFood')

    // Simple focus
    setTimeout(() => {
      const nameInput = document.getElementById('foodName')
      if (nameInput) nameInput.focus()
    }, 100)
  }
  // Hide add food modal
  hideAddFood() {
    this.hideModal('addFood')
  }

  // Show manage tags modal
  showManageTags() {
    this.showModal('manageTags')

    // Focus on tag input
    setTimeout(() => {
      const tagInput = document.getElementById('newTagName')
      if (tagInput) tagInput.focus()
    }, 100)
  }

  // Hide manage tags modal
  hideManageTags() {
    this.hideModal('manageTags')
  }
  // Show add category modal
  showAddCategory() {
    this.showModal('addCategory')

    // Focus on input
    setTimeout(() => {
      const input = document.getElementById('categoryNameInput')
      if (input) input.focus()
    }, 100)
  }

  // Hide add category modal
  hideAddCategory() {
    this.hideModal('addCategory')
  }

  // Close currently active modal
  closeActiveModal() {
    if (this.activeModal) {
      this.hideModal(this.activeModal)
    }
    // Force cleanup body tabIndex
    document.body.removeAttribute('tabIndex')
    document.body.removeAttribute('tabindex')
  }

  resetAllOverlays() {
    // Force all overlays to hide
    Object.values(this.modals).forEach(({ overlay }) => {
      if (overlay) {
        overlay.style.display = 'none'
        overlay.classList.remove('active')
      }
    })

    // Reset pointer events
    document.body.style.pointerEvents = ''
    document.body.style.overflow = ''
  }

  // Check if any modal is open
  isModalOpen() {
    return this.activeModal !== null
  }

  // Get currently active modal
  getActiveModal() {
    return this.activeModal
  }

  // Show confirmation dialog
  showConfirmation(message, onConfirm, onCancel, title) {
    // Set default values
    onCancel = onCancel || null
    title = title || 'Confirm Delete'

    // Store callbacks
    this._confirmCallback = onConfirm
    this._cancelCallback = onCancel

    // Set title and message
    document.getElementById('confirmTitle').textContent = title
    document.getElementById('confirmMessage').textContent = message

    // Show modal
    this.showModalStacked('confirmation')

    // Set up one-time event listeners
    const yesBtn = document.getElementById('confirmYesBtn')
    const noBtn = document.getElementById('confirmNoBtn')

    const handleYes = () => {
      this.hideModalStacked('confirmation')
      if (this._confirmCallback) {
        this._confirmCallback()
      }
      cleanup()
    }

    const handleNo = () => {
      this.hideModalStacked('confirmation')
      if (this._cancelCallback) {
        this._cancelCallback()
      }
      cleanup()
    }

    const cleanup = () => {
      yesBtn.removeEventListener('click', handleYes)
      noBtn.removeEventListener('click', handleNo)
      this._confirmCallback = null
      this._cancelCallback = null
    }

    yesBtn.addEventListener('click', handleYes)
    noBtn.addEventListener('click', handleNo)
  }

  // Show loading state in modal
  showLoading(modalType, message = 'Loading...') {
    const { modal } = this.modals[modalType]
    if (modal) {
      const loadingDiv = document.createElement('div')
      loadingDiv.id = `modalLoading_${modalType}`
      loadingDiv.style.cssText = `
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(255, 255, 255, 0.9);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 9999;
            `
      loadingDiv.innerHTML = `<p style="color: #666;">${message}</p>`
      modal.style.position = 'relative'
      modal.appendChild(loadingDiv)
    }
  }

  // Hide loading state
  hideLoading(modalType = null) {
    if (modalType) {
      const loadingDiv = document.getElementById(`modalLoading_${modalType}`)
      if (loadingDiv) {
        loadingDiv.remove()
      }
    } else {
      // Remove all loading divs
      Object.keys(this.modals).forEach((type) => {
        const loadingDiv = document.getElementById(`modalLoading_${type}`)
        if (loadingDiv) {
          loadingDiv.remove()
        }
      })
    }
  }

  // Animate modal entrance
  animateIn(modalType) {
    const { modal } = this.modals[modalType]
    if (modal) {
      modal.style.transform = 'translate(-50%, -60%) scale(0.9)'
      modal.style.opacity = '0'

      // Trigger animation
      requestAnimationFrame(() => {
        modal.style.transition = `all ${CONFIG.UI.MODAL_ANIMATION_DURATION}ms ease-out`
        modal.style.transform = 'translate(-50%, -50%) scale(1)'
        modal.style.opacity = '1'
      })
    }
  }

  // Animate modal exit
  animateOut(modalType, callback = null) {
    const { modal } = this.modals[modalType]
    if (modal) {
      modal.style.transition = `all ${CONFIG.UI.MODAL_ANIMATION_DURATION * 0.75}ms ease-in`
      modal.style.transform = 'translate(-50%, -60%) scale(0.9)'
      modal.style.opacity = '0'

      setTimeout(() => {
        modal.style.transition = ''
        modal.style.transform = ''
        modal.style.opacity = ''
        if (callback) callback()
      }, CONFIG.UI.MODAL_ANIMATION_DURATION * 0.75)
    } else if (callback) {
      callback()
    }
  }

  // Enhanced show methods with animation (keeping for backward compatibility)
  showFoodDetailsAnimated() {
    this.showFoodDetails()
  }

  showAddFoodAnimated() {
    this.showAddFood()
  }

  showManageTagsAnimated() {
    this.showManageTags()
  }

  // Enhanced hide methods with animation (keeping for backward compatibility)
  hideFoodDetailsAnimated() {
    this.hideFoodDetails()
  }

  hideAddFoodAnimated() {
    this.hideAddFood()
  }

  hideManageTagsAnimated() {
    this.hideManageTags()
  }

  // FIXED: Cleanup method for proper resource management
  destroy() {
    // Remove created overlays
    Object.values(this.modals).forEach(({ overlay }) => {
      if (overlay && overlay.parentNode) {
        overlay.parentNode.removeChild(overlay)
      }
    })

    // Reset body overflow
    document.body.style.overflow = 'auto'

    this.activeModal = null
  }
}
 ui js:
 import { CONFIG } from './config.js'

export class UIManager {
  constructor() {
    this.elements = {
      categoriesContainer: document.getElementById('categoriesContainer'),
      tagsList: document.getElementById('tagsList'),
      existingTags: document.getElementById('existingTags'),
      detailsImage: document.getElementById('detailsImage'),
      detailsName: document.getElementById('detailsName'),
      detailsTags: document.getElementById('detailsTags'),
    }

    // FIXED: Track event listeners for cleanup
    this.eventListeners = new Map()
    this.currentFoodElements = []
    this.currentTagElements = []
  }

  // FIXED: Add event listener with cleanup tracking
  addEventListenerWithCleanup(element, event, handler, identifier) {
    // Remove existing listener if it exists
    this.removeEventListener(identifier)

    // Add new listener
    element.addEventListener(event, handler)

    // Store for cleanup
    this.eventListeners.set(identifier, {
      element,
      event,
      handler,
    })
  }

  // FIXED: Remove specific event listener
  removeEventListener(identifier) {
    const listener = this.eventListeners.get(identifier)
    if (listener) {
      listener.element.removeEventListener(listener.event, listener.handler)
      this.eventListeners.delete(identifier)
    }
  }

  // FIXED: Clean up all event listeners
  cleanup() {
    this.eventListeners.forEach((listener, identifier) => {
      listener.element.removeEventListener(listener.event, listener.handler)
    })
    this.eventListeners.clear()
    this.currentFoodElements = []
    this.currentTagElements = []
  }

  // FIXED: Render all foods in grid layout with proper event management
  renderCategories(categories, isEditMode = false) {
    this.cleanup()
    this.elements.categoriesContainer.innerHTML = ''

    categories.forEach((category) => {
      const categoryDiv = document.createElement('div')
      categoryDiv.className = 'category-container'
      categoryDiv.style.cssText = 'border: 1px solid #ccc; margin: 10px; padding: 10px;'

      const headerDiv = document.createElement('div')
      headerDiv.className = 'category-header' // Add class for drag handle
      headerDiv.style.cssText =
        'display: flex; justify-content: space-between; margin-bottom: 10px;'

      headerDiv.innerHTML = `
            <button onclick="window.dietHelper.showAddFoodForm(${category.id})" style="padding: 5px 10px;">+ Add Food</button>
            <div>
                <span id="categoryName-${category.id}" 
      style="margin-right: 10px; font-weight: bold; padding: 2px 5px;">${this.escapeHtml(category.name)}</span>
                <button onclick="window.dietHelper.startRenameCategory(${category.id})" style="padding: 5px 10px; display: ${isEditMode ? 'inline-block' : 'none'};">Rename</button>
                <button onclick="window.dietHelper.deleteCategory(${category.id})" style="padding: 5px 10px; display: ${isEditMode ? 'inline-block' : 'none'};">Delete</button>
            </div>
        `

      categoryDiv.appendChild(headerDiv)

      const foodsDiv = document.createElement('div')
      foodsDiv.id = `foods-${category.id}` // Add ID for sortable
      foodsDiv.style.cssText = 'display: flex; flex-wrap: wrap;'

      if (category.foods.length === 0) {
        foodsDiv.innerHTML = '<p style="color: #666;">No foods in this category</p>'
      } else {
        category.foods.forEach((food) => {
          const foodDiv = document.createElement('div')
          foodDiv.className = 'food-item'

          foodDiv.innerHTML = `
                   ${
                     food.imageUrl
                       ? `<img src="${food.imageUrl}" class="food-image" data-category-id="${category.id}" data-food-id="${food.id}">`
                       : `<div class="food-image no-image" data-category-id="${category.id}" data-food-id="${food.id}">No Image</div>`
                   }
                    <div class="food-name">${this.escapeHtml(food.name)}</div>
                `

          const imageElement = foodDiv.querySelector('.food-image')
          const clickHandler = () => {
            window.dietHelper.showCategoryFoodDetails(category.id, food.id)
          }

          const listenerId = `food-image-${category.id}-${food.id}`
          this.addEventListenerWithCleanup(imageElement, 'click', clickHandler, listenerId)
          this.currentFoodElements.push(listenerId)

          foodsDiv.appendChild(foodDiv)
        })
      }

      categoryDiv.appendChild(foodsDiv)
      this.elements.categoriesContainer.appendChild(categoryDiv)
    })
  }

  // Render tags for selection in food form
  renderTagsForSelection(tags) {
    this.elements.tagsList.innerHTML = ''

    if (tags.length === 0) {
      const noTagsMsg = document.createElement('p')
      noTagsMsg.textContent = 'No tags available. Add some tags first!'
      noTagsMsg.style.color = '#666'
      noTagsMsg.style.fontSize = '12px'
      this.elements.tagsList.appendChild(noTagsMsg)
      return
    }

    tags.forEach((tag) => {
      const tagDiv = document.createElement('div')
      tagDiv.className = 'tag-item'
      tagDiv.innerHTML = `
                <input type="checkbox" class="tag-checkbox" value="${tag.id}" id="tag_${tag.id}">
                <label for="tag_${tag.id}">${this.escapeHtml(tag.name)}</label>
            `
      this.elements.tagsList.appendChild(tagDiv)
    })
  }

  // FIXED: Render existing tags in manage tags form with proper event management
  renderExistingTags(tags) {
    // Clean up existing tag event listeners
    this.currentTagElements.forEach((identifier) => {
      this.removeEventListener(identifier)
    })
    this.currentTagElements = []

    this.elements.existingTags.innerHTML = ''

    if (tags.length === 0) {
      const noTagsMsg = document.createElement('p')
      noTagsMsg.textContent = 'No tags created yet.'
      noTagsMsg.style.color = '#666'
      noTagsMsg.style.fontSize = '12px'
      this.elements.existingTags.appendChild(noTagsMsg)
      return
    }

    tags.forEach((tag) => {
      const tagDiv = document.createElement('div')
      tagDiv.className = 'tag-item'
      tagDiv.innerHTML = `
                <span>${this.escapeHtml(tag.name)}</span>
                <button class="delete-tag-btn" data-tag-id="${tag.id}" style="margin-left: 10px; padding: 2px 8px; background: #ff4444; color: white; border: none; border-radius: 3px; cursor: pointer;">Delete</button>
            `

      // FIXED: Add click event listener with cleanup tracking
      const deleteBtn = tagDiv.querySelector('.delete-tag-btn')
      const clickHandler = () => {
        window.dietHelper.deleteTag(tag.id)
      }

      const listenerId = `delete-tag-${tag.id}`
      this.addEventListenerWithCleanup(deleteBtn, 'click', clickHandler, listenerId)
      this.currentTagElements.push(listenerId)

      this.elements.existingTags.appendChild(tagDiv)
    })
  }

  // Show food details in modal
  showFoodDetails(food, tags) {
    const tagNames = food.tags
      .map((tagId) => {
        const tag = tags.find((t) => t.id === tagId)
        return tag ? tag.name : ''
      })
      .filter((name) => name)

    // Populate details
    this.elements.detailsImage.src = food.imageUrl || ''
    this.elements.detailsImage.style.display = food.imageUrl ? 'block' : 'none'
    this.elements.detailsImage.style.width = CONFIG.UI.FOOD_IMAGE_SIZE.MODAL.width + 'px'
    this.elements.detailsImage.style.height = CONFIG.UI.FOOD_IMAGE_SIZE.MODAL.height + 'px'

    if (!food.imageUrl) {
      // Show placeholder for no image
      this.elements.detailsImage.style.display = 'block'
      this.elements.detailsImage.src =
        'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSIjZjBmMGYwIi8+PHRleHQgeD0iNTAlIiB5PSI1MCUiIGZvbnQtZmFtaWx5PSJBcmlhbCIgZm9udC1zaXplPSIxNCIgZmlsbD0iIzk5OSIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZHk9Ii4zZW0iPk5vIEltYWdlPC90ZXh0Pjwvc3ZnPg=='
    }

    this.elements.detailsName.textContent = food.name
    this.elements.detailsTags.textContent =
      tagNames.length > 0 ? `Tags: ${tagNames.join(', ')}` : 'No tags'
  }

  // Clear food form
  clearFoodForm() {
    const nameField = document.getElementById('foodName')
    const imageField = document.getElementById('foodImage')
    const errorDiv = document.getElementById('foodNameError')

    if (nameField) nameField.value = ''
    if (imageField) imageField.value = ''
    if (errorDiv) errorDiv.classList.add('hidden')

    // Clear tag selections
    const checkboxes = document.querySelectorAll('.tag-checkbox')
    checkboxes.forEach((cb) => (cb.checked = false))
  }
  rebuildFoodNameInput() {
    const container = document.querySelector('#addFoodDropdown .form-group')
    if (!container) return

    // Remove old input and error div
    const oldInput = document.getElementById('foodName')
    const oldError = document.getElementById('foodNameError')

    if (oldInput) oldInput.remove()
    if (oldError) oldError.remove()

    // Create fresh input
    const newInput = document.createElement('input')
    newInput.type = 'text'
    newInput.id = 'foodName'
    newInput.placeholder = 'Enter food name'

    const newError = document.createElement('div')
    newError.id = 'foodNameError'
    newError.className = 'error-message hidden'
    newError.textContent = 'Please enter food name'

    // Insert at beginning of container
    container.insertBefore(newInput, container.firstChild)
    container.insertBefore(newError, newInput.nextSibling)

    // Focus the new input
    newInput.focus()
  }
  // Clear tag form
  clearTagForm() {
    const tagField = document.getElementById('newTagName')
    const errorDiv = document.getElementById('tagNameError')

    if (tagField) tagField.value = ''
    if (errorDiv) errorDiv.classList.add('hidden')
  }

  // Show/hide error messages
  showError(elementId, message = null) {
    const errorDiv = document.getElementById(elementId)
    if (errorDiv) {
      // Use provided message or default from config
      const errorMessage = message || CONFIG.MESSAGES.ERRORS.FOOD_NAME_REQUIRED
      errorDiv.textContent = errorMessage
      errorDiv.classList.remove('hidden')
    }
  }

  hideError(elementId) {
    const errorDiv = document.getElementById(elementId)
    if (errorDiv) {
      errorDiv.classList.add('hidden')
    }
  }

  // Get selected tags from checkboxes
  getSelectedTags() {
    const selectedTags = []
    const checkboxes = document.querySelectorAll('.tag-checkbox:checked')
    checkboxes.forEach((cb) => {
      selectedTags.push(parseInt(cb.value))
    })
    return selectedTags
  }

  // Get form input values
  getFoodFormData() {
    return {
      name: document.getElementById('foodName')?.value.trim() || '',
      image: document.getElementById('foodImage')?.files[0] || null,
      tags: this.getSelectedTags(),
    }
  }

  getTagFormData() {
    return {
      name: document.getElementById('newTagName')?.value.trim() || '',
    }
  }

  // Utility function to escape HTML
  escapeHtml(text) {
    const div = document.createElement('div')
    div.textContent = text
    return div.innerHTML
  }

  // Show loading state
  showLoading(elementId, message = 'Loading...') {
    const element = document.getElementById(elementId)
    if (element) {
      element.innerHTML = `<p style="text-align: center; color: #666;">${message}</p>`
    }
  }

  // Focus on element
  focusElement(elementId) {
    const element = document.getElementById(elementId)
    if (element) {
      setTimeout(() => element.focus(), 100)
    }
  }

  // FIXED: Cleanup method to be called when UIManager is destroyed
  destroy() {
    this.cleanup()
  }
}

data js:
import { CONFIG, ConfigUtils } from './config.js'

export class DataManager {
  constructor() {
    this.dataFile = CONFIG.FILES.DATA_FILE
    this.imagesDir = CONFIG.FILES.IMAGES_DIR
    this.hiddenCanvas = null // ADD THIS LINE
  }

  // Save data to JSON file
  async saveData(data) {
    try {
      if (typeof require !== 'undefined') {
        // Electron environment
        const { ipcRenderer } = require('electron')
        const result = await ipcRenderer.invoke('save-data', data)
        return result
      } else {
        // Browser fallback
        localStorage.setItem(CONFIG.STORAGE.MAIN_DATA, JSON.stringify(data))
        return { success: true }
      }
    } catch (error) {
      console.error('Error saving data:', error)
      return { success: false, error: error.message }
    }
  }

  // Load data from JSON file
  async loadData() {
    try {
      if (typeof require !== 'undefined') {
        // Electron environment
        const { ipcRenderer } = require('electron')
        const data = await ipcRenderer.invoke('load-data')
        return {
          success: true,
          data: {
            foods: data.foods || [],
            tags: data.tags || [],
            categories: data.categories || [],
          },
        }
      } else {
        // Browser fallback
        const data = JSON.parse(localStorage.getItem(CONFIG.STORAGE.MAIN_DATA) || '{}')
        return {
          success: true,
          data: {
            foods: data.foods || [],
            tags: data.tags || [],
            categories: data.categories || [],
          },
        }
      }
    } catch (error) {
      console.error('Error loading data:', error)
      return {
        success: false,
        data: { foods: [], tags: [], categories: [] },
        error: error.message,
      }
    }
  }

  // Save image file - FIXED: Now converts to base64 for persistence
  async saveImage(imageFile) {
    try {
      if (!imageFile) {
        return { success: false, error: 'No image file provided' }
      }

      // Validate image using ConfigUtils
      const validation = ConfigUtils.validateImage(imageFile)
      if (!validation.valid) {
        return { success: false, error: validation.error }
      }

      if (typeof require !== 'undefined') {
        // Electron environment - save image to file system
        const reader = new FileReader()

        return new Promise((resolve) => {
          reader.onload = async (e) => {
            try {
              const { ipcRenderer } = require('electron')
              const fileName = `food_${Date.now()}.${imageFile.name.split('.').pop()}`
              const result = await ipcRenderer.invoke('save-image', e.target.result, fileName)
              resolve(result)
            } catch (error) {
              resolve({ success: false, error: error.message })
            }
          }
          reader.readAsDataURL(imageFile)
        })
      } else {
        // Browser fallback - convert to base64 for localStorage persistence
        return new Promise((resolve) => {
          const reader = new FileReader()
          reader.onload = (e) => {
            try {
              // Optionally compress image if it's too large
              const base64Data = e.target.result
              if (CONFIG.FEATURES.IMAGE_COMPRESSION && base64Data.length > 500000) {
                // ~375KB
                this.compressImage(base64Data, imageFile.type)
                  .then((compressedData) => {
                    resolve({ success: true, path: compressedData })
                  })
                  .catch((error) => {
                    console.warn('Image compression failed, using original:', error)
                    resolve({ success: true, path: base64Data })
                  })
              } else {
                resolve({ success: true, path: base64Data })
              }
            } catch (error) {
              resolve({ success: false, error: error.message })
            }
          }
          reader.onerror = () => {
            resolve({ success: false, error: 'Failed to read image file' })
          }
          reader.readAsDataURL(imageFile)
        })
      }
    } catch (error) {
      console.error('Error saving image:', error)
      return { success: false, error: error.message }
    }
  }

  async deleteImage(imagePath) {
    try {
      if (!imagePath) return { success: true }

      if (typeof require !== 'undefined') {
        // Electron environment - delete actual file
        try {
          const { ipcRenderer } = require('electron')
          const result = await ipcRenderer.invoke('delete-image', imagePath)
          return result
        } catch (electronError) {
          // If handler not registered, just log warning
          console.warn('Image deletion not implemented in Electron main process')
          return { success: true, warning: 'Image handler not registered' }
        }
      } else {
        // Browser environment - no file to delete (base64 stored in localStorage)
        return { success: true }
      }
    } catch (error) {
      console.error('Error deleting image:', error)
      // Don't fail the food deletion if image deletion fails
      return { success: true, warning: 'Image file could not be deleted' }
    }
  }

  // Compress image to reduce storage size
  async compressImage(base64Data, mimeType) {
    return new Promise((resolve, reject) => {
      // FIXED: Create hidden canvas to prevent visual glitches
      if (!this.hiddenCanvas) {
        this.hiddenCanvas = document.createElement('canvas')
        this.hiddenCanvas.style.cssText = `
                position: absolute;
                left: -9999px;
                top: -9999px;
                visibility: hidden;
            `
        document.body.appendChild(this.hiddenCanvas)
      }

      const canvas = this.hiddenCanvas // Use hidden canvas instead of creating new one
      const ctx = canvas.getContext('2d')
      const img = new Image()

      img.onload = () => {
        // Calculate new dimensions while maintaining aspect ratio
        const maxWidth = 800
        const maxHeight = 600
        let { width, height } = img

        if (width > height) {
          if (width > maxWidth) {
            height = (height * maxWidth) / width
            width = maxWidth
          }
        } else {
          if (height > maxHeight) {
            width = (width * maxHeight) / height
            height = maxHeight
          }
        }

        canvas.width = width
        canvas.height = height

        // Draw and compress
        ctx.drawImage(img, 0, 0, width, height)
        const compressedData = canvas.toDataURL(mimeType || 'image/jpeg', CONFIG.IMAGES.QUALITY)
        resolve(compressedData)
      }

      img.onerror = () => reject(new Error('Failed to load image for compression'))
      img.src = base64Data
    })
  }

  // Validate food data
  validateFood(foodData) {
    const errors = []

    const nameValidation = ConfigUtils.validateFoodName(foodData.name)
    if (!nameValidation.valid) {
      errors.push(nameValidation.error)
    }

    if (!foodData.id || typeof foodData.id !== 'number') {
      errors.push('Food ID is required and must be a number')
    }

    if (foodData.tags && !Array.isArray(foodData.tags)) {
      errors.push('Tags must be an array')
    }

    if (foodData.tags && foodData.tags.length > CONFIG.VALIDATION.MAX_TAGS_PER_FOOD) {
      errors.push(CONFIG.MESSAGES.ERRORS.MAX_TAGS_PER_FOOD)
    }

    return {
      isValid: errors.length === 0,
      errors: errors,
    }
  }

  // Validate tag data
  validateTag(tagData) {
    const errors = []

    const nameValidation = ConfigUtils.validateTagName(tagData.name)
    if (!nameValidation.valid) {
      errors.push(nameValidation.error)
    }

    if (!tagData.id || typeof tagData.id !== 'number') {
      errors.push('Tag ID is required and must be a number')
    }

    return {
      isValid: errors.length === 0,
      errors: errors,
    }
  }

  // Create backup of current data
  async createBackup() {
    try {
      const loadResult = await this.loadData()
      if (!loadResult.success) {
        return { success: false, error: 'Failed to load current data for backup' }
      }

      const backupData = {
        ...loadResult.data,
        backupDate: new Date().toISOString(),
      }

      if (typeof require !== 'undefined') {
        const { ipcRenderer } = require('electron')
        const backupFileName = `backup_${Date.now()}.json`
        // You'd need to add a backup IPC handler in main.js
        // const result = await ipcRenderer.invoke('create-backup', backupData, backupFileName);
        // return result;

        // For now, just return success
        return { success: true, message: 'Backup feature needs IPC handler implementation' }
      } else {
        localStorage.setItem(
          `${CONFIG.STORAGE.BACKUP_PREFIX}${Date.now()}`,
          JSON.stringify(backupData)
        )
        return { success: true, message: 'Backup created in localStorage' }
      }
    } catch (error) {
      console.error('Error creating backup:', error)
      return { success: false, error: error.message }
    }
  }
}

// Export for use in other files
if (typeof module !== 'undefined' && module.exports) {
  module.exports = DataManager
} else {
  window.DataManager = DataManager
}





okay but from now on when i ask you improvement implementation dont give me full code files ok? 
just give me needed part and where i have to add or replace in which file and in which section like 
after that function before that function in that funcvtion ect right?

what is this feature:
**Keyboard shortcuts** - Already defined in config, just need implementation

like how can it be used give me example